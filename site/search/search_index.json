{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gu\u00eda paso a paso de Laravel 9","text":""},{"location":"#que-aprenderas","title":"\u00bfQu\u00e9 aprender\u00e1s?","text":"<p>El curso tiene un enfoque muy pr\u00e1ctico para que comiences construyendo una aplicaci\u00f3n b\u00e1sica paso a paso e ir a\u00f1adiendo funcionalidades de forma progresiva. </p>"},{"location":"#indice-de-contenidos","title":"\u00cdndice de contenidos","text":"<ol> <li>Introducci\u00f3n: qu\u00e9 es Laravel, caracter\u00edsticas principales y su ecosistema. </li> <li>Preparar el entorno de desarrollo</li> <li>Tu primera aplicaci\u00f3n en 7 pasos</li> <li>Laravel nivel intermedio</li> <li>Pr\u00f3ximos pasos (en construcci\u00f3n)</li> </ol>"},{"location":"#como-puedes-contribuir","title":"\u00bfC\u00f3mo puedes contribuir?","text":""},{"location":"#issues","title":"Issues","text":"<p>Si\u00e9nte libre de abrir un issue de Github para reportar errores o sugerir modificaciones.</p>"},{"location":"#contribuir","title":"Contribuir","text":"<p>Sigue los siguientes pasos:</p> <ol> <li>Haz un <code>fork</code> del repositorio en GitHub</li> <li><code>Clone</code> el proyecto en tu entorno local</li> <li>Haz <code>commit</code> de los cambios en tu propia branch</li> <li>Haz <code>push</code> de los cambios a tu fork</li> <li>Env\u00eda una <code>Pull request</code> para que pueda revisar tus cambios</li> </ol>"},{"location":"#notas","title":"Notas","text":"<p>La documentaci\u00f3n est\u00e1 \u00edntegramente escrita en Markdown y compilada a p\u00e1gina est\u00e1tica utilizando Material for MkDocs.</p> <p>Si deseas desplegar la p\u00e1gina en local te interesar\u00e1n los siguientes comandos (consulta la documentaci\u00f3n oficial aqu\u00ed):</p> <p>Crear un nuevo proyecto <pre><code>docker run --rm -it -v ${PWD}:/docs squidfunk/mkdocs-material new .\n</code></pre></p> <p>Lanzar el servidor local para previsualizar los cambios realizados`autom\u00e1ticamente: <pre><code>docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material\n</code></pre></p> <p>Compilar el proyecto generando los archivos est\u00e1ticos: <pre><code>docker run --rm -it -v ${PWD}:/docs squidfunk/mkdocs-material build\n</code></pre></p>"},{"location":"01-introduccion/","title":"Introducci\u00f3n","text":""},{"location":"01-introduccion/#prerequisitos","title":"Prerequisitos","text":"<p>Para seguir esta gu\u00eda \u00fanicamente necesitar\u00e1s conocimientos b\u00e1sicos/medios de PHP y motivaci\u00f3n para aprender. Si todav\u00eda no dispones de estos conocimientos, puedes utilizar el material gratuito disponible en http://jonvadillo.com/learn para comenzar tu aprendizaje.</p> <p>Cualquier editor de texto te servir\u00e1 tambi\u00e9n para programar. No obstante, te recomiendo VS Code o PhpStorm, los cuales considero sin duda alguna dos de los editores para PHP m\u00e1s potentes en la actualidad.</p> <p>\u00a1Comencemos!</p>"},{"location":"01-introduccion/#que-es-laravel","title":"\u00bfQu\u00e9 es Laravel?","text":"<p>Tal y como dice la gu\u00eda oficial, Laravel es un framework de desarrollo de aplicaciones web con una sintaxis elegante que nos permitir\u00e1 desarrollar aplicaciones web de forma r\u00e1pida y segura.</p> <p>El objetivo de Laravel es permitir a los desarrolladores crear aplicaciones web robustas y profesionales, de forma \u00e1gil y con una estructura adecuada. Laravel facilita la implentaci\u00f3n de cualquier funcionalidad que toda aplicaci\u00f3n profesional pueda necesitar (interacci\u00f3n con bases de datos, seguridad, servicios web, etc.).</p> <p>En este libro aprender\u00e1s a crear aplicaciones web con Laravel desde cero, desde lo m\u00e1s b\u00e1sico hasta funcionalidades m\u00e1s complejas que incluyan aspectos como la seguridad o control de acceso.</p>"},{"location":"01-introduccion/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<p>Algunas de las caracter\u00edsticas de Laravel son:</p> <ul> <li>Sistema intuitivo de rutas.</li> <li>Motor de plantillas Blade para la generaci\u00f3n de interfaces de usuario de forma flexible.</li> <li>Soporte para cualquier base de datos mediante Eloquent ORM.</li> <li>Uso de la arquitectura MVC.</li> <li>Dispone de multitud de componentes capaces de resolver las problem\u00e1ticas m\u00e1s comunes del desarrollo de aplicaciones web.</li> <li>Una grande comunidad de desarrolladores y expertos.</li> </ul>"},{"location":"01-introduccion/#ecosistema-laravel","title":"Ecosistema Laravel","text":"<p>Es importante conocer bien los actores principales del ecosistema Laravel:</p> <ul> <li>Router: recibe todas las peticiones y las env\u00eda al controlador adecuado (tambi\u00e9n puede ejecutar alg\u00fan middleware espec\u00edfico antes de llamar al controlador).</li> <li>Controladores (Controllers): contienen toda la l\u00f3gica para reaccionar a las peticiones entrantes.</li> <li>Vistas (Views): contienen el c\u00f3digo HTML y separan la presentaci\u00f3n de la l\u00f3gica de la aplicaci\u00f3n (controlador).</li> <li>Modelos (Models): se utilizan para interactuar con la base de datos y aplicar la l\u00f3gica de negocio.</li> </ul>  <p>Tal y como muestra la imagen anterior, el flujo de una petici\u00f3n en una aplicaci\u00f3n de Laravel ser\u00eda el siguiente:</p> <ol> <li>El punto de entrada de todas las peticiones es el archivo <code>public/index.php</code> el cual se encargar\u00e1 de lanzar una instancia de nuestra aplicaci\u00f3n Laravel.</li> <li>La petici\u00f3n se env\u00eda al router, el cual la reenv\u00eda al controlador correspondiente.</li> <li>El controlador atiende la petici\u00f3n y realiza las acciones correspondientes (por ejemplo, puede interactuar con la base de datos para cargar o almacenar informaci\u00f3n).</li> <li>Por \u00faltimo, el controlador genera la vista correspondiente y se la env\u00eda al cliente.</li> </ol>"},{"location":"01-introduccion/#estructura-de-carpetas","title":"Estructura de carpetas","text":"<p>Laravel crea una estructura de ficheros como punto de partida para todo tipo de aplicaciones:</p> <ul> <li><code>/app</code>: contienne el c\u00f3digo fuente de la aplicaci\u00f3n y la mayor\u00eda de las clases que crearemos. Importante comentar las carpeta <code>/app/Http</code> que almacenar\u00e1 los controladores de la aplicaci\u00f3n que vayamos creando.</li> <li><code>/bootstrap</code>: contiene el archivo <code>app.php</code>, el cual arranca el framework. Tambi\u00e9n contiene la carpeta <code>/cache</code> en la que Laravel almacena los archivos generados y as\u00ed optimizar su rendimiento.</li> <li><code>/config</code>: contiene la configuraci\u00f3n de la aplicaci\u00f3n, de la conexi\u00f3n a base de datos, sistema de ficheros, etc. A pesar de ello, es conveniente realizar los cambios de configuraci\u00f3n en el archivo .ENV y no en los archivos de configuraci\u00f3n de esta carpeta.</li> <li><code>/database</code>: contiene todos los ficheros relacionados con el almacenamiento de datos.</li> <li><code>public</code>: contiene el fichero <code>index.php</code>, el cual ser\u00e1 el punto de entrada a nuestra aplicaci\u00f3n, es decir, recibir\u00e1 todas las peticiones que reciba nuestra aplicaci\u00f3n. <code>/public</code> es el \u00fanico directorio accesible p\u00fablicamente, por lo que contiene todos los archivos est\u00e1ticos: .js, .css y las im\u00e1genes. </li> <li><code>/resources</code>: contiene las vistas de la aplicaci\u00f3n que se utilizar\u00e1n para generar los ficheros HTML y los archivos CSS y JS no compilados (una vez compilados Laravel los guardar\u00e1 en la carpeta <code>/public</code>). Tambi\u00e9n contiene los archivos de traducci\u00f3n.</li> <li><code>/routes</code>: contiene los archivos de rutas a nuestra aplicaci\u00f3n o API. La diferencia entre estos dos, es que el segundo no contiene informaci\u00f3n sobre las sesiones, cookies, etc.</li> <li><code>/storage</code>: contiene las vistas compiladas y otros archivos generados por laravel. La carpeta <code>storage\\app\\public</code> se utilizar\u00e1 para almacenar los archivos subidos por nuestros usuarios (por ejemplo, fotos de perfil).</li> </ul>"},{"location":"02-entorno/","title":"Preparar el entorno de desarrollo","text":"<p>Puedes lanzar una aplicaci\u00f3n desarrollada con Laravel en cualquier m\u00e1quina o servidor con Apache/Nginx, PHP y Composer. Para facilitar la creaci\u00f3n del entorno de desarrollo existen dos opciones principales:</p> <ul> <li>Laravel Homestead. Homestead es una Vagrant box que provee de un entorno de desarrollo con todo el software necesario: PHP, servidor web, base de datos, gestor de dependencias, etc.</li> <li>Laravel Sail. Laravel Sail es una interfaz de l\u00ednea de comandos (CLI)  para interactuar con la configuraci\u00f3n de Docker predeterminada de Laravel. Proporciona una interfaz f\u00e1cil de usar para ejecutar tareas comunes como levantar entornos de desarrollo local, ejecutar pruebas o desplegar aplicaciones.</li> </ul> <p>No obstante, si te sientes m\u00e1s c\u00f3modo utilizando tu propio servidor o entorno de desarrollo, puedes hacerlo perfectamente siempre que cumplas con los requerimientos citados.</p>"},{"location":"02-entorno/#laravel-sail","title":"Laravel Sail","text":"<p>Con Laravel Sail puedes configurar f\u00e1cilmente un entorno de desarrollo local para tu aplicaci\u00f3n Laravel ejecutando un solo comando. Este entorno incluye un servidor de desarrollo PHP, una base de datos MySQL y todas las dem\u00e1s herramientas que se necesitan para empezar a trabajar en una aplicaci\u00f3n. Laravel Sail est\u00e1 disponible para macOS, Linux y Windows (v\u00eda WSL2).</p>"},{"location":"02-entorno/#pasos","title":"Pasos","text":"<p>Para crear una aplicaci\u00f3n de Laravel con Laravel Sail, necesitar\u00e1s tener instalado Docker Desktop. En el caso de Windows, aseg\u00farate tambi\u00e9n que Windows Subsystem for Linux 2 (WSL2) est\u00e1 instalado y habilitado.</p>"},{"location":"02-entorno/#1-crea-un-nuevo-proyecto-de-laravel-utilizando-el-servicio-laravelbuild","title":"1. Crea un nuevo proyecto de Laravel utilizando el servicio laravel.build","text":"<p>Abre una terminal (en el caso de Windows, \u00e1brela iniciando una sesi\u00f3n en WSL2) y ejecuta el siguiente comando dentro del directorio en el que deseas crear tu aplicaci\u00f3n: <pre><code>curl -s \"https://laravel.build/example-app\" | bash\n</code></pre> Sustituye \"example-app\" por el nombre que quieres dar a tu aplicaci\u00f3n.  Otro aspecto importante es que el comando anterior instalar\u00e1 por defecto mysql, redis, meilisearch, mailhog, y selenium. Puedes evitar esto y elegir los servicios que quieres instalar indic\u00e1ndolos como par\u00e1metro al final de la URL: <pre><code>curl -s \"https://laravel.build/example-app?with=mysql,redis\" | bash\n</code></pre></p>"},{"location":"02-entorno/#2-inicia-el-entorno-de-desarrollo","title":"2. Inicia el entorno de desarrollo","text":"<p>Espera a que Laravel Sail instale todas las dependencias necesarias para tu aplicaci\u00f3n. Este proceso puede llevar varios minutos ya que debe preparar todos los contenedores para el desarrollo desde tu m\u00e1quina local.</p> <p>Una vez que la instalaci\u00f3n haya finalizado, entra en la carpeta creada para tu aplicaci\u00f3n <code>cd example-app</code> y ejecuta el comando <code>./vendor/bin/sail up</code> para levantar el entorno de desarrollo local (utiliza <code>./vendor/bin/sail up -d</code> para arrancarlo en el background).</p> <p>Abre tu navegador y visita la direcci\u00f3n http://localhost:8000 para ver tu aplicaci\u00f3n de Laravel en funcionamiento.</p> <p>Ya puedes empezar a trabajar en tu aplicaci\u00f3n de Laravel.</p> <p>Puedes utilizar el comando <code>sail stop</code> para parar el entorno.</p>"},{"location":"02-entorno/#opcional-3-crea-un-alias-para-sail","title":"(Opcional) 3. Crea un alias para sail","text":"<p>Para evitar tener que escribir <code>./vendor/bin/sail</code> continuamente, puedes crear un alias y as\u00ed ejecutar simplemente <code>sail</code> directamente.</p> <p>Edita tu archivo a\u00f1adiendo esto al final del fichero <code>~/.zshrc</code> o <code>~/.bashrc</code>: <pre><code>alias sail='[ -f sail ] &amp;&amp; sh sail || sh vendor/bin/sail'\n</code></pre></p> <p>Una forma sencilla de editar/crear el fichero puede ser mediante el editor de texto nano: <pre><code>nano ~/.zshrc\n</code></pre></p> <p>Vuelve a abrir el terminal y a partir de ahora ya podr\u00e1s ejecutar comandos como <code>sail up</code> o <code>sail stop</code> directamente.</p>"},{"location":"02-entorno/#4-ejecutar-comandos-en-sail","title":"4. Ejecutar comandos en Sail","text":"<p>En Laravel es muy com\u00fan ejecutar comandos de utilizades como Composer, Artisan o Node. Para ejecutar esos comandos sin tener que conectarte al contenedor <code>laravel.test</code> puedes hacerlo de la siguiente forma: <pre><code># Ejemplos de comandos desde dentro del contenedor:\nphp --version\nphp script.php\nphp artisan queue:work\ncomposer require laravel/sanctum\nnode --version\n\n# Ejemplos de comandos utilizando Laravel Sail:\nsail php --version\nsail php script.php\nsail artisan queue:work\nsail composer require laravel/sanctum\nsail node --version\n</code></pre> De todas formas, siempre tienes la opci\u00f3n de conectarte al contenedor con el siguiente comando: <pre><code>docker exec -it &lt;id_contenedor&gt; bash\n</code></pre> Adem\u00e1s del anterior comando, Laravel Sail tambi\u00e9n ofrece la posibilidad de acceder al contenedor mediante el siguiente comando: <pre><code>sail shell\n</code></pre></p>"},{"location":"02-entorno/#5-configuracion-inicial","title":"5. Configuraci\u00f3n inicial","text":"<p>Todos los archivos de configuraci\u00f3n sobre la aplicaci\u00f3n se almacenan en el directorio de configuraci\u00f3n <code>config</code>. Laravel trae una configuraci\u00f3n establecida por defecto, por lo que no es necesario configurar nada adicional para comenzar a desarrollar. No obstante, puedes entrar a ver el archivo <code>config/app.php</code> para hacerte a la idea de distintos par\u00e1metros a configurar.</p> <p>La configuraci\u00f3n relativa al entorno se almacena en el fichero <code>.env</code>. El tipo de configuraci\u00f3n almacenada en este entorno es especialmente aquella que variar\u00e1 en funci\u00f3n de si se trata de un entorno de desarrollo local, producci\u00f3n, etc. Nunca deber\u00edas subir este fichero a tu repositorio de c\u00f3digo (por ejemplo Github).</p>"},{"location":"02-entorno/#6-base-de-datos","title":"6. Base de datos","text":"<p>Por defecto Laravel Sail crea dos bases de datos autom\u00e1ticamente. La primera con el mismo nombre de la aplicaci\u00f3n. Puedes encontrar los datos relativos a la base de datos en el fichero <code>.env</code>. <pre><code>DB_CONNECTION=mysql\nDB_HOST=mysql\nDB_PORT=3306\nDB_DATABASE=example_app\nDB_USERNAME=sail\nDB_PASSWORD=password\n</code></pre> Si deseas conectarte a la base de datos (mediante TablePlus o MySQL Workbench por ejemplo) deber\u00e1s utilizar los datos de conexi\u00f3n de este fichero.</p> <p>La segunda es una base de datos llamada <code>test</code> que se utilizar\u00e1 para testing (en caso de necesitarlo).</p>"},{"location":"02-entorno/#7-configuracion-adicional","title":"7. Configuraci\u00f3n adicional","text":"<p>Si quieres saber m\u00e1s detalles sobre la configuraci\u00f3n de Sail, como por ejemplo cambiar la versi\u00f3n de PHP por defecto o configurar opciones de testing, puedes visitar el siguiente enlace: https://laravel.com/docs/9.x/sail</p>"},{"location":"02-entorno/#8-posibles-errores","title":"8. Posibles errores","text":"<p>\u00bfErrores durante la configuraci\u00f3n del entorno? En este gist encontrar\u00e1s algunos errores comunes y su posible soluci\u00f3n.</p>"},{"location":"02-entorno/#laravel-homestead","title":"Laravel Homestead","text":""},{"location":"02-entorno/#pasos_1","title":"Pasos","text":""},{"location":"02-entorno/#1-instalar-virtualbox-6x","title":"1. Instalar VirtualBox 6.x","text":"<p>Descarga VirtualBox desde la p\u00e1gina web oficial www.virtualbox.org e inst\u00e1lalo en tu ordenador. Tambi\u00e9n puedes utilizar VMWare, Parallels o Hyper-V en lugar de Virtual Box.</p>"},{"location":"02-entorno/#2-instalar-vagrant","title":"2. Instalar Vagrant.","text":"<p>Descarga e instala Vagrant tal y como lo indica la documentaci\u00f3n de la p\u00e1gina web oficial https://www.vagrantup.com.</p>"},{"location":"02-entorno/#3-anadir-laravelhomestead-box-a-tu-instalacion-de-vagrant","title":"3. A\u00f1adir laravel/homestead box a tu instalaci\u00f3n de Vagrant","text":"<p>Una Vagrant box es una imagen base utilizada para clonar de forma r\u00e1pida y sencilla una m\u00e1quina virtual. Ejecuta el siguiente comando para descargar e instalar la Vagrant box the Larabel y as\u00ed poder utilizarla para crear tantos entornos como quieras.</p> <pre><code>vagrant box add laravel/homestead\n</code></pre> <p>Puedes comprobar que se ha a\u00f1adido correctamente utilizando el comando <code>vagrant box list</code>.</p>"},{"location":"02-entorno/#4-instalar-homestead","title":"4. Instalar Homestead","text":"<p>Clona el repositorio oficial de Homestead en un directorio. Como recomendaci\u00f3n, puedes clonarlo en una carpeta llamada Homestead en la ra\u00edz de tu sistema, y utilizar esta m\u00e1quina virtual para todos tus proyectos de Laravel.</p> <pre><code>git clone https://github.com/laravel/homestead.git ~/Homestead\n</code></pre>"},{"location":"02-entorno/#5-crea-el-archivo-de-configuracion-homesteadyaml","title":"5. Crea el archivo de configuraci\u00f3n Homestead.yaml","text":"<p>Ejecuta el comando init.sh en un terminal dentro del directorio donde clonaste Homestead. Este comando crear\u00e1 el archivo de configuraci\u00f3n Homestead.yaml.</p> <pre><code>// Mac / Linux...\nbash init.sh\n\n// Windows...\ninit.bat\n</code></pre> <p>El archivo Homestead.yaml creado tendr\u00e1 el siguiente aspecto:</p> <pre><code>ip: \"192.168.10.10\"\nmemory: 2048\ncpus: 2\nprovider: virtualbox\n\nauthorize: ~/.ssh/id_rsa.pub\n\nkeys:\n    - ~/.ssh/id_rsa\n\nfolders:\n    - map: ~/code\n      to: /home/vagrant/code\n\nsites:\n    - map: homestead.test\n      to: /home/vagrant/code/public\n\ndatabases:\n    - homestead\n</code></pre>"},{"location":"02-entorno/#6-genera-las-claves-ssh","title":"6. Genera las claves ssh","text":"<p>Si no dispones de unas clasves ssh en el sistema necesitar\u00e1s generarlas desde un terminal. Para saber si ya dispones de ellas, intanta encontrar el directorio <code>.ssh</code> en tu sistema operativo (normalmente suele encontrarse en C:\\Users\\USER_NAME en Windows y el el directorio ra\u00edz ~ en Linux/Mac ) y busca dos archivos llamados <code>id_rsa</code> y <code>id_rsa.pub</code>. Si los has encontrado, puedes saltarte este paso. En caso contrario, lanza el siguiente comando desde la consola:</p> <pre><code>ssh-keygen -t rsa -C \"your_email@example.com\"\n</code></pre> <p>El script te realizar\u00e1 algunas preguntas, simplemente pulsa ENTER y te crear\u00e1 los archivos <code>id_rsa</code> y <code>id_rsa.pub</code> en un directorio con nombre <code>.ssh</code>.</p>"},{"location":"02-entorno/#7-configurar-homestead","title":"7. Configurar Homestead","text":"<p>En esta instalaci\u00f3n no tendr\u00e1s que tocar el archivo <code>Vagrantfile</code> (probablemente est\u00e9s familiarizado con \u00e9l ya que es t\u00edpicamente el utilizado para configurar el entorno). Homestead delega la configuraci\u00f3n en el archivo <code>Homestead.yaml</code>,  por lo que a continuaci\u00f3n te mostraremos las opciones m\u00e1s importantes que tendr\u00e1s que configurar:</p> <ul> <li>ssh keys: el fichero de configuraci\u00f3n Homestead.yaml tendr\u00e1 la configuraci\u00f3n realizada correctamente tanto para Mac como Linux. Si est\u00e1s utilizando Windows, modifica los siguientes valores:</li> </ul> <pre><code>authorize: c:/Users/USER_NAME/.ssh/id_rsa.pub\n\nkeys:\n    - c:/Users/USER_NAME/.ssh/id_rsa\n</code></pre> <ul> <li>Shared folders: en este apartado se indican los directorios de tu sistema operativo que se mantendr\u00e1n sincronizados con la m\u00e1quina virtual creada. Modifica el valor de 'map' y escribe la carpeta donde almacenas tus proyectos (p.ej. <code>/Users/USER_NAME/dev/proyectos</code> en Linux/Mac o <code>c:/dev/proyectos</code> en Windows).  En el siguiente ejemplo puedes ver c\u00f3mo se sincronizar\u00edan los ficheros de nuestra carpeta <code>~/code/projects</code> en la carpeta <code>/home/vagrant/projects</code> de nuestra m\u00e1quina virtual: <pre><code>folders:\n    - map: ~/code/projects\n      to: /home/vagrant/projects\n</code></pre></li> <li>Sites: La propiedad sites permite mapear f\u00e1cilmente un dominio con un directorio de nuestro entorno virtual. De este forma podremos utilizar el dominio indicado (p.ej. aplicacion1.test) para acceder a nuestra aplicaci\u00f3n desde el navegador. Ten en cuenta que el punto de entrada a una aplicaci\u00f3n de Laravel es el archivo <code>index.php</code> ubicado en la carpeta <code>/public</code> de nuestro proyecto Laravel, por lo que el dominio tendr\u00e1 que apuntar siempre a esta carpeta. Por ejemplo: <pre><code>sites:\n    - map: aplicacion1.test\n      to: /home/vagrant/projects/aplicacion1/public\n    - map: aplicacion2.test\n      to: /home/vagrant/projects/aplicacion2/public\n</code></pre></li> </ul>"},{"location":"02-entorno/#8-configurar-el-archivo-local-hosts","title":"8. Configurar el archivo local hosts","text":"<p>Es probable que vayas a utilizar el entorno virtual creado para m\u00faltiples proyectos o aplicaciones, por lo que necesitar\u00e1s a\u00f1adir los dominios indicados en el anterior apartado de 'sites' al archivo <code>hosts</code> de tu ordenador. De esta forma puedes redirigir las peticiones a dominios concretos a aplicaciones de tu entorno virtual Homestead.</p> <p>Modifica el archivo <code>hosts</code> (lo encontrar\u00e1s en <code>/etc/hosts</code> en Mac/Linux y en <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> en Windows):</p> <pre><code>192.168.10.10  aplicacion1.test\n192.168.10.10  aplicacion2.test\n</code></pre> <p>Para evitar otro tipo de problemas, la recomendaci\u00f3n general es utilizar dominios de tipo \".localhost\", \".invalid\", \".test\", or \".example\".</p>"},{"location":"02-entorno/#9-arrancar-y-prueba-el-entorno-creado","title":"9. Arrancar y prueba el entorno creado","text":"<p>Una vez ya tenemos Homestead configurado y el archivo <code>hosts</code> modificado, ya podemos ir al directorio <code>Homestead</code> y ejecutar el siguiente comando para arranchar la m\u00e1quina virtual (la primera vez tardar\u00e1 m\u00e1s tiempo al tener que realizar la preparaci\u00f3n del entorno):</p> <pre><code>vagrant up\n</code></pre> <p>Puedes acceder mediante SSH a tu m\u00e1quina virtual:</p> <pre><code>vagrant ssh\n</code></pre> <p>\u00a1Enhorabuena! Ya est\u00e1s preparado para comenzar a crear tu primera aplicaci\u00f3n web con Laravel.</p> <p>Puedes detener la m\u00e1quina virtual con el comando <code>vagrant halt</code>.</p>"},{"location":"02-entorno/#error-input-file-not-specified","title":"Error 'input file not specified'","text":"<p>Es posible que al intentar cargar una aplicaci\u00f3n el navegador te muestre el mensaje 'input file not specified'. Esto es algo com\u00fan cuando por ejemplo cambiamos el archivo <code>host</code> y a\u00f1adimos alguna URL m\u00e1s. En caso de que te aparezca este error, para la m\u00e1quina virtual y vu\u00e9lvela arrancar con el siguiente comando:</p> <pre><code>vagrant up --provision\n</code></pre>"},{"location":"02-entorno/#error-de-vboxmanage","title":"Error de VBoxManage","text":"<p>Es posible que a la hora de hacer <code>vagrant up</code> no finalice correctamente y muestre el siguiente error:</p> <pre><code>There was an error while executing `VBoxManage`, a CLI used by Vagrant\nfor controlling VirtualBox. The command and stderr is shown below.\n\nCommand: [\"startvm\", \"b3d4e98d-8a88-4335-8430-28a731e02f07\", \"--type\", \"headless\"]\n\nStderr: VBoxManage.exe: error: Failed to open/create the internal network 'HostInterfaceNetworking-VirtualBox Host-Only Ethernet Adapter #2' (VERR_INTNET_FLT_IF_NOT_FOUND).\nVBoxManage.exe: error: Failed to attach the network LUN (VERR_INTNET_FLT_IF_NOT_FOUND)\nVBoxManage.exe: error: Details: code E_FAIL (0x80004005), component ConsoleWrap, interface IConsole.\n</code></pre> <p>El error puede ser debido a las versiones de Vagrant y VirtualBox utilizadas. Para solucionarlo deber\u00eda ser suficiente con actualizar VirtualBox. Tambi\u00e9n puede ser necesario desinstalar el Extension Pack anterior e instalar la \u00faltima versi\u00f3n.</p>"},{"location":"02-entorno/#bonus-extensiones-de-vs-code-para-desarrollar-en-laravel","title":"Bonus: Extensiones de VS Code para desarrollar en Laravel","text":"<p>Puedes instalar algunas extensiones de VS Code para facilitar el desarrollo con Laravel. En el siguiente enlace tienes una recopilaci\u00f3n de las m\u00e1s recomendadas:</p> <p>https://devdojo.com/bobbyiliev/8-awesome-vs-code-extensions-for-laravel-developers</p>"},{"location":"03-primeros-pasos/","title":"Tu primera aplicaci\u00f3n en 7 pasos","text":"<p>Ahora que ya tenemos nuestro entorno de desarrollo preparado, crearemos una aplicaci\u00f3n web con Laravel paso por paso. Al finalizar los 7 pasos que encontrar\u00e1s en este cap\u00edtulo, obtendremos como resultado una revista online a la que hemos llamado RevistApp. Esta aplicaci\u00f3n mostrar\u00e1 los art\u00edculos de una revista almacenados en una base de datos. \u00bfComenzamos?</p>"},{"location":"03-primeros-pasos/#paso-1-crea-tu-primer-proyecto","title":"Paso 1 - Crea tu primer proyecto","text":"<p>Este paso no es necesario realizarlo si has optado por utilizar Laravel Sail, ya que Sail crear\u00e1 autom\u00e1ticamente una nueva aplicaci\u00f3n junto con el entorno.</p> <p>Si has decidido utilizar Laravel Homestead o Vagrant como tu entorno de desarrollo, entonces deber\u00e1s realizar las siguientes acciones:</p>"},{"location":"03-primeros-pasos/#crea-la-aplicacion-dentro-de-la-maquina-virtual","title":"Crea la aplicaci\u00f3n dentro de la m\u00e1quina virtual","text":"<p>Accede a tu m\u00e1quina virtual utilizando el comando <code>vagrant ssh</code> y posicionate en la carpeta donde almacenar\u00e1s tus proyectos (la carpeta que has indicado en el archivo de configuraci\u00f3n <code>Homestead.yaml</code>, por ejemplo: <code>/home/vagrant/proyects</code>). Ejecuta el siguiente comando para crear un nuevo proyecto:</p> <pre><code>composer create-project laravel/laravel revistapp\n</code></pre> <p>Si recibes un error, probablemente sea porque todav\u00eda no tienes Composer instalado en tu m\u00e1quina virtual. Para ello, ejecuta el siguiente comando:</p> <pre><code>composer global require laravel/installer\n</code></pre> <p>Una vez instalado vuelve a ejecutar el comando <code>create-project</code> de Composer. Este comando inicializar\u00e1 un nuevo proyecto creando en el directorio <code>revistapp</code>. Puedes acceder a la aplicaci\u00f3n entrando a http://aplicacion1.test (o el dominio que hayas indicado en la configuraci\u00f3n) desde tu navegador favorito.</p> <p>De forma alternativa tambi\u00e9n puedes utilizar el comando <code>laravel new</code> que tambi\u00e9n crear\u00e1 un nuevo proyecto de Laravel en la carpeta especificada:</p> <pre><code>laravel new revistapp\n</code></pre> <p>Puedes entrar a la nueva carpeta del proyecto creada, <code>revistapp</code>, para ver los archivos que se han generada. A partir de ahora siempre trabajaremos dentro de este directorio. </p> <p>Ten en cuenta que en este caso, al haber creado una aplicaci\u00f3n llamada <code>revistapp</code>, deber\u00e1s tener una entrada en tu archivo de configuraci\u00f3n <code>Homestead.yaml</code> que referencia a la carpeta <code>/public</code> del proyecto reci\u00e9n creado:</p> <pre><code>sites:\n    - map: articulos.test\n      to: /home/vagrant/code/revistapp/public\n</code></pre>"},{"location":"03-primeros-pasos/#generar-la-clave-de-la-aplicacion-application-key","title":"Generar la clave de la aplicaci\u00f3n (Application Key)","text":"<p>Laravel utiliza una clave para securizar tu aplicaci\u00f3n. La clave de aplicaci\u00f3n es un string de 32 caracteres utilizado para encriptar datos como la sesi\u00f3n de usuario. Cuando se instala Laravel utilizando Composer o el instalador de Laravel, la clave se genera autom\u00e1ticamente, por lo que no es necesario hacer nada. Comprueba que existe un valor para <code>APP_KEY</code> en el fichero de configuraci\u00f3n <code>.env</code>. En caso de no tener una clave generada, cr\u00e9ala utilizando el siguiente comando:</p> <pre><code>php artisan key:generate\n</code></pre>"},{"location":"03-primeros-pasos/#establecer-los-permisos-de-directorio","title":"Establecer los permisos de directorio","text":"<p>Homestead realiza este paso por nosotros, por lo que si est\u00e1s utilizando Homestead los permisos deber\u00edan estar correctamente establecidos. Si no est\u00e1s utilizando Homestead o quieres desplegar tu aplicaci\u00f3n en un servidor, no olvides establecer permisos de escritura para el servidor web en los directorios <code>storage</code> y  <code>bootstrap/cache</code>.</p>"},{"location":"03-primeros-pasos/#hands-on-17","title":"Hands on! (1/7)","text":"<p>Si no lo has hecho ya, crea una aplicaci\u00f3n llamada <code>revistapp</code>. Esta ser\u00e1 la aplicaci\u00f3n que iremos creando paso a paso.</p>"},{"location":"03-primeros-pasos/#paso-2-crear-un-router","title":"Paso 2 - Crear un Router","text":"<p>Las rutas son los puntos de entrada a nuestra aplicaci\u00f3n. Cada vez que un usuario hace una petici\u00f3n a una de las rutas de la aplicaci\u00f3n, Laravel trata la petici\u00f3n mediante un Router definido en el directorio <code>routes</code>, el cual ser\u00e1 el encargado de direccionar la petici\u00f3n a un Controlador. Las rutas accesibles para navegadores estar\u00e1n definidas en el archivo <code>routes/web.php</code> y aquellas accesibles para servicios web (webservices) estar\u00e1n definidas en el archivo <code>routes/api.php</code>. A continuaci\u00f3n se muestra un ejemplo:</p> <pre><code>Route::get('/articulos', function () {\n    return '\u00a1Vamos a leer unos articulos!';\n});\n</code></pre> <p>El c\u00f3digo anterior muestra c\u00f3mo se define una ruta b\u00e1sica. En este caso, cuando el usuario realice una petici\u00f3n sobre <code>/articulos</code>, nuestra aplicaci\u00f3n ejecutar\u00e1 la funci\u00f3n an\u00f3nima definida. En este caso enviar\u00e1 una respuesta al usuario con el string '\u00a1Vamos a leer unos articulos!'.</p> <p>Podemos especificar tantas rutas como queramos:</p> <pre><code>Route::get('/articulos', function () {\n    return '\u00a1Vamos a leer unos articulos!';\n});\n\nRoute::get('/usuarios', function () {\n    return 'Hay muchos usuarios en esta aplicaci\u00f3n';\n});\n</code></pre> <p>Tambi\u00e9n es posible responder a peticiones de tipo POST, por ejemplo para recibir datos de formularios: </p> <pre><code>Route::get('/articulos', function () {\n    return '\u00a1Vamos a leer unos articulos!';\n});\n\nRoute::post('/articulos', function () {\n    return '\u00a1Vamos a insertar un art\u00edculo!';\n});\n</code></pre> <p>Aparte de ejecutar las acciones definidas para cada ruta, Laravel ejecutar\u00e1 el middlewere espec\u00edfico en funci\u00f3n del Router utilizado (por ejemplo, el middlewere relacionado con las peticiones web proveer\u00e1 de funcionalidades como el estado de la sesi\u00f3n o la protecci\u00f3n CSRF).</p>"},{"location":"03-primeros-pasos/#ver-las-rutas-creadas","title":"Ver las rutas creadas","text":"<p>La utilidad Artisan de Laravel nos provee de comandos muy \u00fatiles (por ejemplo, para crear controladores o migraciones). Disponemos de un comando concreto para mostrar todas las rutas de una aplicaci\u00f3n de forma r\u00e1pida. Basta con ejecutar el siguiente comando en la consola:</p> <p><pre><code>php artisan route:list\n</code></pre> Recuerda que si est\u00e1s utilizando Laravel Sail, puedes ejecutar el comando directamente los comandos de artisan incluyendo <code>sail</code> al princicio:</p> <pre><code>sail artisan route:list\n</code></pre> <p>Si quieres que Laravel no muestre las rutas creadas por paquetes de terceros (vendor) puedes a\u00f1adir el flag <code>except-vendor</code> al final: <pre><code>php artisan route:list --except-vendor\n</code></pre></p>"},{"location":"03-primeros-pasos/#devolver-un-json","title":"Devolver un JSON","text":"<p>Tambi\u00e9n es posible devolver un JSON. Laravel convertir\u00e1 autom\u00e1ticamente cualquier array a JSON:</p> <pre><code>Route::get('/articulos', function () {\n    $articulos = [\n        [\n            \"id\" =&gt; 1,\n            \"titulo\" =&gt; \"Primer art\u00edculo...\"\n        ],\n        [\n            \"id\" =&gt; 1,\n            \"titulo\" =&gt; \"Segundo art\u00edculo...\"\n        ]\n    ];\n    return $articulos;\n});\n</code></pre>"},{"location":"03-primeros-pasos/#parametros-en-la-ruta","title":"Par\u00e1metros en la ruta","text":"<p>Una URL puede contener informaci\u00f3n de nuestro inter\u00e9s. Laravel permite acceder a esta informaci\u00f3n de forma sencilla utilizando los par\u00e1metros de ruta:</p> <pre><code>Route::get('articulos/{id}', function ($id) {\n    return 'Vas a leer el art\u00edculo: '.$id;\n});\n</code></pre> <p>Los par\u00e1metros de ruta vienen definidos entre llaves <code>{}</code> y se inyectan autom\u00e1ticamente en las callbacks. Es posible utilizar m\u00e1s de un par\u00e1metro de ruta:</p> <pre><code>Route::get('articulos/{id}/usuario/{name}', function ($id, $name) {\n    return 'Vas a leer el art\u00edculo: '.$id. ' del usuario' .$name;\n});\n</code></pre> <p>Para indicar un par\u00e1metro como opcional, le tenemos que a\u00f1adir el s\u00edmbolo <code>?</code> al final del par\u00e1mentro. Le tendremos que a\u00f1adir un valor por defecto para asegurarnos su correcto funcionamiento:</p> <pre><code>Route::get('articulos/{id?}', function ($id = 0) {\n    return 'Vas a leer el art\u00edculo: '.$id;\n});\n</code></pre>"},{"location":"03-primeros-pasos/#acceder-a-la-informacion-de-la-peticion","title":"Acceder a la informaci\u00f3n de la petici\u00f3n","text":"<p>Tambi\u00e9n es posible acceder a la informaci\u00f3n enviada en la petici\u00f3n mediante el m\u00e9todo <code>request()</code>. Por ejemplo, el siguiente c\u00f3digo devolver\u00e1 el valor enviado para el par\u00e1metro 'fecha' de la URL <code>/articulos?fecha=hoy</code>:</p> <pre><code>Route::get('/articulos', function () {\n    $fecha = request('fecha');\n    return $fecha;\n});\n</code></pre>"},{"location":"03-primeros-pasos/#rutas-con-nombre","title":"Rutas con nombre","text":"<p>Es posible asignar nombres a las rutas que sirvan para referirnos a ellas. De esta forma, en caso de que la URL de una ruta cambie, \u00fanicamente tendremos que cambiarlo en el router y no en todos los ficheros HTML donde estemos enlazando a dicha ruta.</p> <p>Para especificar el nombre a una ruta debemos utilizar la funci\u00f3n <code>name()</code>, la cual deber\u00e1 recibir como par\u00e1metro el nombre que se desea asignar a la ruta:</p> <pre><code>Route::get('/articulos', function () {\n    return \"Ruta con nombre!\";\n})-&gt;name('articulos.index');\n</code></pre> <p>En un futuro veremos c\u00f3mo generar las URLs a partir de su nombre. Por ejemplo, en lugar de utilizar:</p> <pre><code>&lt;a href=\"/articulos\"&gt;Ver art\u00edculos&lt;/a&gt;\n</code></pre> <p>utilizaremos:</p> <pre><code>&lt;a href=\"{{ route('articulos.index') }}\"&gt;Ver art\u00edculos&lt;/a&gt;\n</code></pre>"},{"location":"03-primeros-pasos/#hands-on-27","title":"Hands on! (2/7)","text":"<p>A\u00f1ade a tu aplicaci\u00f3n <code>revistapp</code> dos nuevas rutas.  - <code>articulos/</code>: Devolver\u00e1 un array de art\u00edculos en formato JSON. Asigna el nombre <code>articulos.index</code> a la ruta utilizando la funci\u00f3n <code>name()</code>. - <code>articulos/{id}</code>: Devolver\u00e1 la siguiente frase: \"Gracias por leer el art\u00edculo con id: {id}\". Asigna el nombre <code>articulos.show</code> a la ruta utilizando la funci\u00f3n <code>name()</code>. </p>"},{"location":"03-primeros-pasos/#solucion","title":"Soluci\u00f3n","text":"<pre><code>Route::get('/articulos', function () {\n    $articulos = [\n        [\"id\" =&gt; 1, \"titulo\" =&gt; \"Primer art\u00edculo...\"],\n        [\"id\" =&gt; 2, \"titulo\" =&gt; \"Segundo art\u00edculo...\"],\n        [\"id\" =&gt; 3, \"titulo\" =&gt; \"Tercer art\u00edculo...\"],\n    ];\n    return $articulos;\n})-&gt;name('articulos.index');\n\nRoute::get('articulos/{id}', function ($id) {\n    $frase = \"Gracias por leer el art\u00edculo con id: \" . $id;\n    return $frase;\n})-&gt;name('articulos.show');\n</code></pre>"},{"location":"03-primeros-pasos/#paso-3-crear-una-vista","title":"Paso 3 - Crear una vista","text":""},{"location":"03-primeros-pasos/#definiendo-una-vista-sencilla","title":"Definiendo una vista sencilla","text":"<p>Las vistas son plantillas que contienen el HTML que enviar\u00e1 nuestra aplicaci\u00f3n a los usuarios. Se almacenan en el directorio <code>/resources/views</code> de nuestro proyecto.</p> <pre><code>&lt;!-- vista almacenada en /resources/views/articulos.blade.php --&gt;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;\u00a1Vamos a leer unos art\u00edculos!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Tendr\u00e1n la extensi\u00f3n <code>.blade.php</code> ya que Laravel utiliza el motor de plantillas Blade, como veremos m\u00e1s adelante.</p>"},{"location":"03-primeros-pasos/#devolver-una-vista","title":"Devolver una vista","text":"<p>Cargar y devolver una vista al usuario es tan sencillo como utilizar la funci\u00f3n global (helper) <code>view()</code>:</p> <p><pre><code>Route::get('/articulos', function () {\n    return view('articulos');\n})-&gt;name('articulos');\n</code></pre> Al indicarle el nombre de la vista como par\u00e1metro no es necesario indicar la ruta completa de la vista ni la extensi\u00f3n <code>.blade.php</code>. Laravel asume que las vistas estar\u00e1n en la carpeta <code>/resources/views</code> y que tendr\u00e1n la extensi\u00f3n <code>.blade.php</code>.</p>"},{"location":"03-primeros-pasos/#acceder-a-datos-desde-la-vista","title":"Acceder a datos desde la vista","text":"<p>Laravel utiliza el motor de plantillas Blade por defecto. Un motor de plantillas permite crear vistas empleando c\u00f3digo HTML junto con c\u00f3digo espec\u00edfico del motor empleado. De esta forma podremos mostrar informaci\u00f3n almacenada en variables, crear condiciones if/else, estructuras repetitivas, etc.</p> <p>En Blade mostrar datos almacenados en variables es muy sencillo:</p> <pre><code>&lt;?php $nombre = \"Nora\"; ?&gt;\n&lt;html&gt;\n    &lt;body&gt;\n    &lt;h1&gt;Vamos a leer al escritor {{ $nombre }}&lt;/h1&gt;\n        &lt;/ul&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Tal y como se puede ver en el ejemplo anterior, basta con escribir el nombre de la variable entre llaves <code>{{ }}</code>. Es una buena pr\u00e1ctica evitar mezclar el c\u00f3digo PHP con nuestras vistas, por lo que toda la informaci\u00f3n que necesitemos en las vistas la ubicaremos fuera de ellas. Existen distintas formas de pasarle variables a las vistas:</p> <p>La primera opci\u00f3n ser\u00eda utilizando el m\u00e9todo <code>with()</code>, pas\u00e1ndole como par\u00e1metros el nombre de la variable y su valor:</p> <pre><code>Route::get('/', function () {\n    $nombre = \"Nora\";\n    return view('saludo')-&gt;with('nombre', $nombre);\n});\n</code></pre> <p>Otra forma ser\u00eda envi\u00e1ndolo como array:</p> <pre><code>Route::get('/', function () {\n    $nombre = \"Nora\";\n    return view('saludo')-&gt;with(['nombre' =&gt; $nombre]);\n});\n</code></pre> <p>Tambi\u00e9n podr\u00edamos pasar el array como segundo par\u00e1metro de la funci\u00f3n <code>view()</code> y no utilizar <code>with()</code>:</p> <pre><code>Route::get('/', function () {\n    $nombre = \"Nora\";\n    return view('saludo',['nombre' =&gt; $nombre]);\n});\n</code></pre> <p>Blade permite iterar por los datos de una colecci\u00f3n o array. El siguiente ejemplo muestra c\u00f3mo iterar por un array de strings de forma r\u00e1pida:</p> <pre><code>&lt;!-- Vista almacenada en resources/views/articulos.blade.php --&gt;\n&lt;html&gt;\n    &lt;body&gt;\n    &lt;h1&gt;Vamos a leer al escritor {{ $nombre }}&lt;/h1&gt;\n        &lt;h2&gt;Estos son sus \u00faltimos art\u00edculos:&lt;/h2&gt;\n        &lt;ul&gt;\n            @foreach ($articulos as $articulo)\n                &lt;li&gt;{{ $articulo }}&lt;/li&gt;\n            @endforeach\n        &lt;/ul&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En el caso anterior, la vista muestra el valor de la variable <code>nombre</code> e itera por el array <code>articulos</code>, por lo que ser\u00e1 necesario proporcionarle dichos datos en la llamada al m\u00e9todo <code>view()</code>:</p> <p><pre><code>Route::get('/articulos', function () {\n    $articulos = array('Primero', 'Segundo','Tercero', '\u00daltimo');\n    return view('articulos', [\n        'nombre' =&gt; 'Ane Aranceta',\n        'articulos' =&gt; $articulos\n    ]);\n})-&gt;name('articulos');\n</code></pre> El motor de plantillas Blade permite el uso de todo tipo de estructuras:</p> <pre><code>@for ($i = 0; $i &lt; 10; $i++)\n    El valor actual es {{ $i }}\n@endfor\n\n@foreach ($users as $user)\n    &lt;p&gt;El usuario: {{ $user-&gt;id }}&lt;/p&gt;\n@endforeach\n\n@forelse($users as $user)\n    &lt;li&gt;{{ $user-&gt;name }}&lt;/li&gt;\n@empty\n    &lt;p&gt;No users&lt;/p&gt;\n@endforelse\n\n@while (true)\n    &lt;p&gt;Eso es un bucle infinito.&lt;/p&gt;\n@endwhile\n\n@if (count($articulos) === 1)\n    Hay un art\u00edculo.\n@elseif (count($articulos) &gt; 1)\n    Hay varios art\u00edculos.\n@else\n    No hay ninguno.\n@endif\n\n@unless (Auth::check())\n    No estas autenticado.\n@endunless\n</code></pre> <p>Puedes encontrar toda la informaci\u00f3n acerca de Blade en la documentaci\u00f3n oficial.</p>"},{"location":"03-primeros-pasos/#hands-on-37","title":"Hands on! (3/7)","text":"<p>Actualiza las rutas de tu aplicaci\u00f3n para que comiencen a devolver vistas al usuario:  - <code>/articulos</code>: Devolver\u00e1 una vista que muestre los art\u00edculos en una tabla. La primera columna tendr\u00e1 un enlace a la ruta del art\u00edculo, utilizando su <code>id</code>. La segunda columna contendr\u00e1 el t\u00edtulo del art\u00edculo. - <code>articulos/{id}</code>: Devolver\u00e1 una vista que contenga un p\u00e1rrafo con la siguiente frase: \"Gracias por leer el art\u00edculo con id {id}\". Tambi\u00e9n tendr\u00e1 un enlace para voler a cargar ruta que muestra todos los ar\u00edculos. </p>"},{"location":"03-primeros-pasos/#solucion_1","title":"Soluci\u00f3n","text":"<p><code>/resources/views/articulos/index.blade.php</code>: <pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;RevistApp&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Revistapp&lt;/h1&gt;\n    &lt;h2&gt;Listado art\u00edculos:&lt;/h2&gt;\n    &lt;table&gt;\n        &lt;tr&gt;&lt;th&gt;Enlace&lt;/th&gt;&lt;th&gt;T\u00edtulo&lt;/th&gt;&lt;/tr&gt;\n        @foreach ($articulos as $articulo)\n        &lt;tr&gt;\n            &lt;td&gt;&lt;a href=\"{{ route('articulos.show', $articulo['id']) }}\"&gt;Ver&lt;/a&gt;&lt;/td&gt;\n            &lt;td&gt;{{ ($articulo['titulo']) }}&lt;/td&gt;\n        &lt;/tr&gt;\n        @endforeach\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <code>/resources/views/articulos/show.blade.php</code>: <pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;RevistApp&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Revistapp&lt;/h1&gt;\n    &lt;h2&gt;Detalle del art\u00edculo:&lt;/h2&gt;\n    &lt;p&gt;Gracias por leer el art\u00edculo con id: {{ $id }}&lt;/p&gt;\n    &lt;a href=\"{{ route('articulos.index') }}\"&gt;Volver&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <code>routes/web.php</code>: <pre><code>Route::get('/articulos', function () {\n    $articulos = [\n        [\"id\" =&gt; 1, \"titulo\" =&gt; \"Primer art\u00edculo...\"],\n        [\"id\" =&gt; 2, \"titulo\" =&gt; \"Segundo art\u00edculo...\"],\n        [\"id\" =&gt; 3, \"titulo\" =&gt; \"Tercer art\u00edculo...\"],\n    ];\n    return view('articulos.index', [\n        'articulos' =&gt; $articulos\n    ]);\n})-&gt;name('articulos.index');\n\nRoute::get('articulos/{id}', function ($id) {\n    return view('articulos.show', [\n        'id' =&gt; $id\n    ]);\n})-&gt;name('articulos.show');\n</code></pre></p>"},{"location":"03-primeros-pasos/#paso-4-crear-un-controlador","title":"Paso 4 - Crear un Controlador","text":"<p>Los controladores contienen la l\u00f3gica para atender las peticiones recibidas. En otras palabras, un Controlador es una clase que agrupa el comportamiento de todas las peticiones relacionadas con una misma entidad. Por ejemplo, el controlador <code>ArticuloController</code> ser\u00e1 el encargado de definir el comportamiento de acciones como: creaci\u00f3n de un art\u00edculo, modificaci\u00f3n de un art\u00edculo, b\u00fasqueda de art\u00edculos, etc.</p>"},{"location":"03-primeros-pasos/#creando-un-controller","title":"Creando un Controller","text":"<p>Existen dos formas de crear un controlador:</p> <ul> <li>Crear manualmente una clase que extienda de la clase <code>Controller</code> de Laravel dentro del directorio <code>app/Http/Controllers</code>.</li> <li>Utilizar el comando de Artisan <code>make:controller</code>. Artisan es una herramienta que nos provee Laravel para interactuar con la aplicaci\u00f3n y ejecutar instrucciones.</li> </ul> <p>En este caso escogeremos la segunda opci\u00f3n y ejecutaremos el siguiente comando:</p> <pre><code>php artisan make:controller ArticuloController\n# recuerda que si est\u00e1s utilizado Sail el comando ser\u00e1: sail artisan ...\n</code></pre> <p>De este modo Laravel crear\u00e1 autom\u00e1ticamente un controlador vac\u00edo, que vendr\u00e1 a ser una subclase de la clase <code>Controller</code>:.</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass ArticuloController extends Controller\n{\n    //\n}\n</code></pre> <p>Como hemos comentado antes los controladores son los responsables de procesar las peticiones entrantes y devolver al cliente la respuesta. Es decir, el router \u00fanicamente tendr\u00e1 que invocar al controlador correspondiente para que atienda la petici\u00f3n entrante.</p> <p>En el siguiente ejemplo se muestra c\u00f3mo a\u00f1adirle m\u00e9todos que devuelvan vistas (como se puede ver en el caso de la funci\u00f3n de nombre <code>show()</code>). Tal y como se puede apreciar, moveremos la l\u00f3gica de la aplicaci\u00f3n del router al controlador.</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\User;\n\nclass ArticuloController extends Controller\n{\n    /**\n     * Show the profile for the given user.\n     *\n     * @param  int  $id\n     * @return View\n     */\n    public function show($id)\n    {\n        return view('articulos.show', [\n            'id' =&gt; $id\n        ]);\n    }\n}\n</code></pre> <p>Es posible a\u00f1adir m\u00e1s opciones al comando <code>make:controller</code>, aunque el \u00fanico obligatorio es el nombre del controlador.  por ejemplo el flag  <code>--resource</code> al comando anterior, Artisan incluir\u00e1 en el controlador creado los siete m\u00e9todos REST m\u00e1s comunes: <code>index()</code>, <code>create()</code>, <code>store()</code>, <code>show()</code>, <code>edit()</code>, <code>update()</code>, <code>destroy()</code>:</p> <pre><code>php artisan make:controller ArticuloController --resource\n</code></pre> <p>Cada m\u00e9todo tiene su funci\u00f3n:</p>    Tipo URI M\u00e9todo Acci\u00f3n     GET /articulos index Muestra todos los art\u00edculos   GET /articulos/create create Muestra el formulario para crear un art\u00edculo   POST /articulos store Guarda un nuevo art\u00edculo a partir de la informaci\u00f3n recibida   GET /articulos/{id} show Muestra la informaci\u00f3n de un art\u00edculo espec\u00edfico   GET /articulos/{id}/edit edit Muestra el formulario de edici\u00f3n de un art\u00edculo que ya existe   PUT/PATCH /articulos/{id} update Guardar los cambios del art\u00edculo indicado a partir de la informaci\u00f3n recibida   DELETE /articulos/{id} destroy Elimina el art\u00edculo con el ID indicado"},{"location":"03-primeros-pasos/#enrutar-el-controlador","title":"Enrutar el Controlador","text":"<p>El siguiente paso es incluir en el Router las llamadas a los m\u00e9todos del Controlador. En este caso crearemos las siguientes como ejemplo:</p> <p><pre><code>use App\\Http\\Controllers\\ArticuloController;\n\nRoute::get('articulos/', [ArticuloController::class, 'index'])-&gt;name('articulos.index');\nRoute::get('articulos/{id}', [ArticuloController::class, 'show'])-&gt;name('articulos.show');\nRoute::get('articulos/create', [ArticuloController::class, 'create'])-&gt;name('articulos.create');\nRoute::post('articulos/', [ArticuloController::class, 'store'])-&gt;name('articulos.store');\n</code></pre> De esta forma direccionaremos las peticiones a los m\u00e9todos de los controladores. Recuerda que el router no debe incluir ninguna l\u00f3gica de la aplicaci\u00f3n, \u00fanicamente redireccionar las peticiones a los controladores.</p> <p>Existe tambi\u00e9n otra forma m\u00e1s r\u00e1pida para generar autom\u00e1ticamente las rutas a todos los m\u00e9todos de nuestro controlador:</p> <pre><code>Route::resource('articulos', ArticuloController::class);\n</code></pre> <p>Si ejecutamos el comando <code>php artisan route:list</code> podemos comprobar c\u00f3mo ya disponemos de todas las rutas a nuestro recurso y que cada una apunta al m\u00e9todo correspondiente en el controlador.</p> <p>Esta opci\u00f3n de <code>Route::resource</code> tambi\u00e9n ofrece la posibilidad de generar \u00fanicamente las rutas que le indiquemos. El siguiente ejemplo muestra como generar \u00fanicamene las rutas index y create utilizando el m\u00e9todo <code>only()</code>:</p> <pre><code>Route::resource('articulos', ArticuloController::class)-&gt;only([\n    'index', 'create'\n]);\n</code></pre>"},{"location":"03-primeros-pasos/#hands-on-47","title":"Hands on! (4/7)","text":"<p>Crea un controlador llamado <code>ArticuloController.php</code> y mueve la l\u00f3gica de las dos rutas del router <code>articulos/</code> y <code>articulos/{id}</code> al nuevo controlador.</p>"},{"location":"03-primeros-pasos/#solucion_2","title":"Soluci\u00f3n","text":"<p><code>/App/Http/Controllers/ArticuloController.php</code>: <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\nuse Illuminate\\Http\\Request;\n\nclass ArticuloController extends Controller\n{\n\n    public function index()\n    {\n        $articulos = [\n            [\"id\" =&gt; 1, \"titulo\" =&gt; \"Primer art\u00edculo...\"],\n            [\"id\" =&gt; 2, \"titulo\" =&gt; \"Segundo art\u00edculo...\"],\n            [\"id\" =&gt; 3, \"titulo\" =&gt; \"Tercer art\u00edculo...\"],\n        ];\n        return view('articulos.index', [\n            'articulos' =&gt; $articulos\n        ]);\n    }\n\n    public function show($id)\n    {\n        return view('articulos.show', [\n            'id' =&gt; $id\n        ]);\n    }\n}\n</code></pre></p> <p>El router pasar\u00e1 a indicar el controlador y el m\u00e9todo que se encargar\u00e1 de cada petici\u00f3n: <pre><code>use App\\Http\\Controllers\\ArticuloController;\n\nRoute::get('articulos', [ArticuloController::class, 'index'])-&gt;name('articulos.index');\nRoute::get('articulos/{id}', [ArticuloController::class, 'show'])-&gt;name('articulos.show');\n</code></pre></p>"},{"location":"03-primeros-pasos/#paso-5-configurar-la-base-de-datos","title":"Paso 5 - Configurar la base de datos","text":"<p>Es muy dif\u00edcil de imaginar una aplicaci\u00f3n web que no haga uso de una base de datos para almacenar la informaci\u00f3n. A continuaci\u00f3n veremos como preparar la base de datos para nuestra aplicaci\u00f3n.</p>"},{"location":"03-primeros-pasos/#configuracion-de-la-base-de-datos","title":"Configuraci\u00f3n de la base de datos","text":"<p>El fichero <code>.env</code> de Laravel contiene la configuraci\u00f3n relacionada con la aplicaci\u00f3n y el entorno, como por ejemplo la configuraci\u00f3n de la base de datos. Abre el fichero <code>.env</code> para visualizar las credenciales de la base de datos:</p> <p><pre><code># Ejemplo de configuraci\u00f3n creada por Laravel Sail\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=revistapp\nDB_USERNAME=sail\nDB_PASSWORD=password\n</code></pre> Todas estas variables de configuraci\u00f3n ser\u00e1n referenciadas desde el archivo de configuraci\u00f3n <code>database.php</code>.</p>"},{"location":"03-primeros-pasos/#solo-en-homestead-creacion-de-la-base-de-datos","title":"(Solo en Homestead) Creaci\u00f3n de la base de datos","text":"<p>Este paso solo ser\u00e1 necesario si estamos utilizando Laravel Homestead y no le hemos indicado a Homestead en su archivo de configuraci\u00f3n <code>Homestead.yaml</code> que cree una base de datos. Para crear la base de datos accede al cliente de MySQL como root:</p> <pre><code>mysql -u root\n</code></pre> <p>Crea la base de datos si no est\u00e1 creada:</p> <pre><code>CREATE DATABASE revistapp;\n</code></pre>"},{"location":"03-primeros-pasos/#crear-un-usuario-de-base-de-datos","title":"Crear un usuario de base de datos","text":"<p>Es recomendable utilizar un usuario de base de datos diferente a <code>root</code>. Si deseas crear un nuevo usuario con permisos de acceso \u00fanicamente para la base de datos de la aplicaci\u00f3n, ejecuta lo siguiente desde MySQL:</p> <pre><code>CREATE USER 'nombre_usuario'@'localhost' IDENTIFIED BY 'tu_contrasena';\n</code></pre> <p>El comando anterior crea el usuario con la contrase\u00f1a indicada. El siguiente paso es otorgar permisos al usuario:</p> <pre><code>GRANT ALL PRIVILEGES ON * . * TO 'nombre_usuario'@'localhost';\n</code></pre> <p>Para que los cambios surjan efecto ejecuta lo siguiente:</p> <pre><code>FLUSH PRIVILEGES;\n</code></pre> <p>No olvides actualizar los datos de acceso a base de datos en el fichero de configuraci\u00f3n <code>.env</code>.</p>"},{"location":"03-primeros-pasos/#paso-6-crear-la-migracion-migration","title":"Paso 6 - Crear la Migraci\u00f3n (Migration)","text":"<p>Las Migraciones (Migrations) se utilizan para construir el esquema de la base de datos, es decir, crear y modificar las tablas que utilizar\u00e1 nuestra aplicaci\u00f3n. Ejecuta el siguiente comando de Artisan para crear una nueva Migraci\u00f3n para una tabla que llamaremos \"articulos\". </p> <pre><code>php artisan make:migration create_articulos_table --create=articulos\n</code></pre> <p>Laravel crear\u00e1 una nueva migraci\u00f3n autom\u00e1ticamente en el directorio <code>database/migrations</code>. El nombre del archivo creado ser\u00e1 el indicado en el comando anterior, en este caso <code>create_articulos_table</code>, precedido por un timestamp, por ejemplo: <code>2022_12_21_162755_create_articulos_table.php</code>.</p> <p>El contenido de la clase creada ser\u00e1 el siguiente:</p> <pre><code>&lt;?php\n\nuse Illuminate\\Database\\Migrations\\Migration;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\n\nreturn new class extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('articulos', function (Blueprint $table) {\n            $table-&gt;id();\n            $table-&gt;timestamps();\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::dropIfExists('articulos');\n    }\n};\n</code></pre> <p>Tal y como puedes deducir del c\u00f3digo anterior, una migraci\u00f3n contiene 2 m\u00e9todos:</p> <ul> <li><code>up()</code>: se utiliza para crear nuevas tablas, columnas o \u00edndices a la base de datos.</li> <li><code>down()</code>: se utiliza para revertir operaciones realizadas por el m\u00e9todo <code>up()</code>.</li> </ul> <p>El siguiente paso es implementar el m\u00e9todo <code>up()</code> para que cree las columnas tal y como queremos:</p> <pre><code>public function up()\n{\n    Schema::create('articulos', function (Blueprint $table) {\n        // Completar con los campos que queremos que contenta la tabla 'articulos':\n        $table-&gt;id(); # Columna de tipo integer autoincremental (equivalente a UNSIGNED INTEGER)\n        $table-&gt;string('titulo'); # Columna de tipo string (equivalente a VARCHAR)\n        $table-&gt;text('contenido'); # Columna de tipo text (equivalente a TEXT)\n        $table-&gt;timestamps(); # Crea las columnas created_at y updated_at de tipo TIMESTAMP.\n    });\n}\n\n/**\n * Reverse the migrations.\n *\n * @return void\n */\npublic function down()\n{\n    Schema::dropIfExists('articulos');\n}\n</code></pre> <p>Aparte de <code>id()</code>, <code>string()</code> o <code>integer()</code>, existen una gran variedad de tipos de columnas disponibles para definir las tablas. Puedes encontrarlas en la documentaci\u00f3n oficial.</p> <p>Una vez tenemos definida una migraci\u00f3n, solo quedar\u00e1 ejecutarla para que as\u00ed se ejecute en nuestra base de datos y aplique los cambios indicados. Para ejecutar las migraciones simplemente lanza el comando <code>migrate</code> de Artisan:</p> <pre><code>php artisan migrate\n</code></pre>"},{"location":"03-primeros-pasos/#hands-on-57","title":"Hands on! (5/7)","text":"<p>Crea una migraci\u00f3n para una tabla llamada <code>articulos</code> siguiendo los pasos anteriormente descritos. Completa la funci\u00f3n <code>up()</code> para definir la tabla y lanza la migraci\u00f3n.</p>"},{"location":"03-primeros-pasos/#paso-7-crear-un-modelo","title":"Paso 7 - Crear un Modelo","text":"<p>Laravel incluye por defecto Eloquent ORM, el cual hace de la interacci\u00f3n con la base de datos una tarea f\u00e1cil. Tal y como dice la documentaci\u00f3n oficial:</p>  <p>Each database table has a corresponding \"Model\" which is used to interact with that table. Models allow you to query for data in your tables, as well as insert new records into the table.</p>  <p>En otras palabras, cada tabla de la base de datos corresponde a un Modelo, el cual permite ejecutar operaciones sobre esa tabla (insertar o leer registros por ejemplo). Este patr\u00f3n es conocido como Active Record Pattern.</p> <p>El nombre del modelo ser\u00e1 la forma singular del nombre asignado a la tabla de la base de datos. Por ejemplo: <code>User</code> ser\u00e1 el modelo correspondiente a la tabla <code>users</code>.</p>"},{"location":"03-primeros-pasos/#creando-un-modelo","title":"Creando un Modelo","text":"<p>Vamos a crear un Modelo:</p> <pre><code>php artisan make:model Articulo\n</code></pre> <p>El comando anterior ha creado una clase llamada Articulo en el directorio <code>app/Models</code> (es el directorio por defecto para los modelos de Eloquent a partir de Laravel 8).</p> <pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Articulo extends Model\n{\n    //\n}\n</code></pre> <p>Por defecto un modelo de Eloquent almacena los registros en una tabla con el mismo nombre pero en plural. En este caso, <code>Articulo</code> interactuar\u00e1 con la tabla de la base de datos llamada <code>articulos</code>.</p> <p>Laravel protege por defecto los modelos de forma que no se puedan generar registros de forma \"masiva\", es decir, en una \u00fanica petici\u00f3n. De esta forma nos protegemos por ejemplo de que un usuario al editar su perfil pueda cambiar el valor de una propiedad llamada <code>is_admin</code>. Para que Laravel permita crear un art\u00edculo desde un formulario com\u00fan, debemos indicarle los campos que podr\u00e1n ser completados y procesados. Para ello incluimos los nombres de los campos en una propiedad llamada <code>fillable</code>.</p> <pre><code>&lt;?php\n\nnamespace App;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nclass Articulo extends Model\n{\n    use HasFactory;\n    protected $fillable = [\n        'titulo',\n        'contenido',\n    ];\n}\n</code></pre>"},{"location":"03-primeros-pasos/#consultando-datos-de-la-base-de-datos","title":"Consultando datos de la base de datos","text":"<p>Los modelos de Eloquent se pueden utilizar para recuperar informaci\u00f3n de las tablas relacionadas con ese modelo. Proporcionan m\u00e9todos como los siguientes:</p> <pre><code>use App\\Models\\Articulo;\n\n// Recupera todos los modelos\n$articulos = Articulo::all();\n\n// Recupera un modelo a partir de su clave\n$articulo = Articulo::find(1);\n\n// Recupera el primer modelo que cumpla con los criterios indicados\n$articulos = Articulo::where('active', 1)-&gt;first();\n\n// Recupera los modelos que cumplan con los criterios indicados y de la forma indicada:\n$articulos = Articulo::where('active', 1)\n               -&gt;orderBy('titulo', 'desc')\n               -&gt;take(10)\n               -&gt;get();\n</code></pre> <p>Es posible iterar por la colecci\u00f3n que devuelven los m\u00e9todos <code>all()</code>, <code>get()</code> o <code>first()</code> de la siguiente forma:</p> <pre><code>foreach ($articulos as $articulo) {\n    echo $articulo-&gt;titulo;\n}\n</code></pre> <p>Es importante mencionar que los m\u00e9todos como <code>all()</code> o <code>get</code> no devuelven arrays t\u00edpicos de PHP si no que devuelven una instancia de la clase <code>Collection</code> de Laravel. La diferencia es que estas colecciones tienen m\u00e9todos adicionales que pueden ayudarnos en distintas situaciones, como por ejemplo: <code>last()</code>, <code>count()</code>, <code>sort()</code>, <code>merge()</code>, <code>filter()</code>, ... Puedes encontrar la lista de estos m\u00e9todos de ayuda aqu\u00ed: https://laravel.com/docs/9.x/collections#available-methods</p>"},{"location":"03-primeros-pasos/#insertar-informacion-en-la-base-de-datos","title":"Insertar informaci\u00f3n en la base de datos","text":"<p>El flujo de interacci\u00f3n que seguir\u00e1 un usuario para insertar nuevos registros (art\u00edculos en nuestro caso) ser\u00e1 el siguiente: 1. Acceder a la p\u00e1gina con el formulario para enviar los datos. La ruta a la que deber\u00e1 acceder ser\u00e1 la siguiente: <code>articulos/create/</code> 2. Enviar los datos del formulario. La ruta que recibir\u00e1 los datos ser\u00e1 la siguiente: <code>articulos/</code> (POST). 3. Una vez enviados los datos, si todo ha ido bien nuestra aplicaci\u00f3n le mostrar\u00e1 una nueva p\u00e1gina.</p> <p>Por lo tanto, ser\u00e1 necesario crear dos nuevas rutas que invoquen a los m\u00e9todos <code>create()</code> y <code>store()</code> del controlador.</p> <p>El fichero <code>/routes/web.php</code> quedar\u00e1 as\u00ed: <pre><code>use App\\Http\\Controllers\\ArticuloController;\n\nRoute::get('articulos', [ArticuloController::class, 'index'])-&gt;name('articulos.index');\nRoute::get('articulos/create', [ArticuloController::class, 'create'])-&gt;name('articulos.create');\nRoute::get('articulos/{id}', [ArticuloController::class, 'show'])-&gt;name('articulos.show');\nRoute::post('articulos/', [ArticuloController::class, 'store'])-&gt;name('articulos.store');\n</code></pre></p> <p>La ruta empleada para mostrar el formulario ser\u00e1 de tipo <code>GET</code> y la encargada de almacenar los datos ser\u00e1 de tipo <code>POST</code>.</p> <p>A continuaci\u00f3n ser\u00e1 necesario implementar los m\u00e9todos del controlador:</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Models\\Articulo;\nuse Illuminate\\Http\\Request;\n\nclass ArticuloController extends Controller\n{\n\n    public function create()\n    {\n        return view('articulos.create');\n    }\n\n    public function store(Request $request)\n    {\n        //Validar la petici\u00f3n:\n        $validated = $request-&gt;validate([\n            'titulo' =&gt; 'required|string|max:255',\n            'contenido' =&gt;'required|string'\n        ]);\n        /* Si la validaci\u00f3n falla se redirigir\u00e1 al usuario \n        a la p\u00e1gina previa. Si pasa la validaci\u00f3n, el controlador \n        continuar\u00e1 ejecut\u00e1ndose.\n        */\n\n        // Insertar el art\u00edculo en la BBDD tras su validaci\u00f3n.\n        Articulo::create($validated);\n\n        return redirect(route('articulos.index'));\n    }\n}\n</code></pre> <p>En el m\u00e9todo <code>store()</code> se ha incluido una validaci\u00f3n de los datos. Para conocer m\u00e1s acerca de las validaciones autom\u00e1ticas que Laravel puede hacer por nosotros, puedes visitar este enlace.</p> <p>Si no se quiere validar los datos (no recomendado) se podr\u00eda haber creado el nuevo art\u00edculo de la siguiente forma:</p> <p><pre><code>    ...\n    public function store(Request $request)\n    {\n\n        $articulo = new Articulo;\n        $articulo-&gt;titulo = request('titulo');\n        $articulo-&gt;contenido = request('contenido');\n        $articulo-&gt;save();\n\n        // Otra alternativa para la inserci\u00f3n:\n        $articulo = Articulo::create([\n            'titulo' =&gt; request('titulo'),\n            'contenido' =&gt; request('contenido')\n         ]);\n\n        return redirect(route('articulos.index'));\n    }\n}\n</code></pre> En el ejemplo anterior se puede apreciar que el m\u00e9todo <code>request()</code> permite acceder a los datos enviados en la petici\u00f3n.</p> <p>Por \u00faltimo, quedar\u00eda crear la vista que muestre el formulario:</p> <p><code>/resources/views/articulos/create.blade.php</code>: <pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;RevistApp&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Revistapp&lt;/h1&gt;\n    &lt;h2&gt;Crear un art\u00edculo:&lt;/h2&gt;\n\n    &lt;form method=\"POST\" action=\"{{ route('articulos.store') }}\"&gt;\n        @csrf\n        &lt;p&gt;&lt;label&gt;Titulo: &lt;/label&gt;&lt;input type=\"text\" name=\"titulo\"&gt;&lt;/p&gt;\n        &lt;p&gt;&lt;label&gt;Contenido: &lt;/label&gt;&lt;input type=\"text\" name=\"contenido\"&gt;&lt;/p&gt;\n        &lt;button type=\"submit\"&gt;Crear&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;a href=\"{{ route('articulos.index') }}\"&gt;Volver&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> La directiva @csrf agrega un campo oculto con el Token de usuario para que Laravel nos proteja autom\u00e1ticamente de ataques XSS o de suplantaci\u00f3n de identidad. Es necesario agregar siempre esta directiva.</p>"},{"location":"03-primeros-pasos/#valores-por-defecto-de-un-modelo","title":"Valores por defecto de un modelo","text":"<p>Al crear una instancia nueva de un modelo, los atributos de la instancia no tendr\u00e1n ning\u00fan valor establecido. Si queremos definir valores por defecto, es posible hacerlo de la siguiente forma:</p> <p><pre><code>&lt;?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Articulo extends Model\n{\n    /**\n     * The model's default values for attributes.\n     *\n     * @var array\n     */\n    protected $attributes = [\n        'publicado' =&gt; false,\n    ];\n}\n</code></pre> El ejemplo anterior muestra c\u00f3mo establecer el atributo <code>publicado</code> como <code>false</code> cada vez que creemos un nuevo objeto de la clase <code>Articulo</code>.</p>"},{"location":"03-primeros-pasos/#alternativas-a-eloquent-orm","title":"Alternativas a Eloquent ORM","text":"<p>Laravel tambi\u00e9n permite interactuar con la base de datos mediante otras t\u00e9cnicas distintas a Eloquent ORM. Las alternativas disponibles son: - Raw SQL: se trata de ejecutar sentencias SQL directamente contra la base de datos. Tienes toda la informaci\u00f3n disponible aqu\u00ed. - Query Builder: es una interfaz de comunicaci\u00f3n con la base de datos que permite lanzar pr\u00e1cticamente cualquier consulta. A diferencia de la anterior, no es tan eficiente en cuanto a rendimiento pero aporta otras ventajas como la seguridad y abstracci\u00f3n de base de datos. Tienes toda la informaci\u00f3n disponible aqu\u00ed.</p>"},{"location":"03-primeros-pasos/#tinker-un-potente-repl-para-laravel","title":"Tinker: un potente REPL para Laravel","text":"<p>Tinker es un potente REPL o consola interactiva que viene por defecto en Laravel. Resulta muy \u00fatil durante el desarrollo ya que permite interactuar con nuestra aplicaci\u00f3n Laravel y probar cantidad de cosas: eventos, acceso a datos, etc. Para iniciar Tinker hay que ejecutar el siguiente comando:</p> <pre><code>php artisan tinker\n</code></pre> <p>A partir de ese momento se puede comenzar a interactuar con nuestra aplicaci\u00f3n, como muestra el ejemplo a continuaci\u00f3n:</p> <pre><code>&gt;&gt;&gt; $articulo = new App\\Models\\Articulo\n=&gt; App\\Articulo {#3014}\n&gt;&gt;&gt; $articulo-&gt;titulo=\"AA\";\n=&gt; \"AA\"\n&gt;&gt;&gt; $articulo-&gt;contenido=\"BBBB\";\n=&gt; \"BBBB\"\n&gt;&gt;&gt; $articulo\n=&gt; App\\Models\\Articulo {#3014\n     titulo: \"Articulo numero 2\",\n     contenido: \"Lorem ipsum...\",\n   }\n&gt;&gt;&gt; $articulos-&gt;save();\n&gt;&gt;&gt; App\\Models\\Articulo::count();\n=&gt; 2\n&gt;&gt;&gt; $articulos = App\\Models\\Articulo::all();\n=&gt; Illuminate\\Database\\Eloquent\\Collection {#3035\n     all: [\n       App\\Models\\Articulo {#3036\n         id: 1,\n         titulo: \"Articulo numero 1\",\n         contenido: \"Lorem ipsum...\",\n         created_at: null,\n         updated_at: null,\n       },\n       App\\Models\\Articulo {#3046\n         id: 2,\n         titulo: \"Articulo numero 2\",\n         contenido: \"Lorem ipsum...\",\n         created_at: \"2019-12-15 15:32:04\",\n         updated_at: \"2019-12-15 15:32:04\",\n       },\n     ],\n   }\n</code></pre> <p>Para salir se ejecuta el comando <code>exit</code>.</p>"},{"location":"03-primeros-pasos/#hands-on-67","title":"Hands on! (6/7)","text":"<p>Crea una vista para crear nuevos art\u00edculos y los m\u00e9todos <code>create()</code> y <code>store()</code> en los controladores. De esta forma tu aplicaci\u00f3n ya podr\u00e1 crear art\u00edculos sin problemas. Tienes las soluciones en los c\u00f3digos proporcionados junto con la explicaci\u00f3n.</p>"},{"location":"03-primeros-pasos/#hands-on-77","title":"Hands on! (7/7)","text":"<ul> <li>Actualiza el m\u00e9todo <code>index()</code> para que utilice los datos almacenados en la base de datos. Puedes utilizar el m\u00e9todo <code>all()</code> para recoger todos los art\u00edculos de la base de datos.</li> <li>Actualiza el m\u00e9todo <code>show()</code> para que muestre el t\u00edtulo y el contenido del art\u00edculo seleccionado.</li> <li>A\u00f1ade tambi\u00e9n en la p\u00e1gina incial un enlace a la p\u00e1gina de creaci\u00f3n de art\u00edculos.</li> </ul>"},{"location":"03-primeros-pasos/#solucion_3","title":"Soluci\u00f3n","text":"<p><code>/App/Http/Controllers/ArticuloController.php</code>: <pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse App\\Models\\Articulo;\n\nclass ArticuloController extends Controller\n{\n\n    public function index()\n    {\n        $articulos = Articulo::all();\n        return view('articulos.index', [\n            'articulos' =&gt; $articulos\n        ]);\n    }\n\n    public function show($id)\n    {\n        $articulo = Articulo::find($id);\n        return view('articulos.show', [\n            'articulo' =&gt; $articulo\n        ]);\n    }\n\n    ...\n\n}\n</code></pre></p> <p>Actualiza la vista <code>index.blade.php</code> para que utilice los datos correctamente y muestre el nuevo enlace:</p> <p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;RevistApp&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Revistapp&lt;/h1&gt;\n    &lt;h2&gt;Listado art\u00edculos:&lt;/h2&gt;\n    &lt;a href=\"{{ route('articulos.create') }}\"&gt;Crear nuevo&lt;/a&gt;\n    &lt;table&gt;\n        &lt;tr&gt;&lt;th&gt;Enlace&lt;/th&gt;&lt;th&gt;T\u00edtulo&lt;/th&gt;&lt;/tr&gt;\n        @foreach ($articulos as $articulo)\n        &lt;tr&gt;\n            &lt;td&gt;&lt;a href=\"{{ route('articulos.show', $articulo-&gt;id) }}\"&gt;Ver&lt;/a&gt;&lt;/td&gt;\n            &lt;td&gt;{{ ($articulo-&gt;titulo) }}&lt;/td&gt;\n        &lt;/tr&gt;\n        @endforeach\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> Actualiza la vista <code>show.blade.php</code> para que utilice los datos reales del art\u00edculo seleccionado: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;RevistApp&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Revistapp&lt;/h1&gt;\n    &lt;h2&gt;Detalle del art\u00edculo:&lt;/h2&gt;\n    &lt;p&gt;Titulo: {{ $articulo-&gt;titulo }}&lt;/p&gt;\n    &lt;p&gt;Contenido: {{ $articulo-&gt;contenido }}&lt;/p&gt;\n    &lt;a href=\"{{ route('articulos.index') }}\"&gt;Volver&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"03-primeros-pasos/#bonus-opciones-flags-de-artisan","title":"Bonus - Opciones (flags) de Artisan","text":"<p>Existen opciones muy \u00fatiles para generar archivos relacionados con los modelos. El siguiente ejemplo crea un modelo junto con su controlador y migraci\u00f3n utilizando un \u00fanico comando:</p> <pre><code>php artisan make:model Articulo -mcr\n</code></pre> <ul> <li>-m indica la creaci\u00f3n de una migraci\u00f3n</li> <li>-c indica la creaci\u00f3n de un controlador</li> <li>-r indica que el controlador creado ser\u00e1 \"resourceful\" (incializado con los m\u00e9todos).</li> </ul>"},{"location":"03-primeros-pasos/#siguientes-pasos","title":"Siguientes pasos","text":"<p>Ahora que ya tienes creada una aplicaci\u00f3n de Laravel capaz de mostrar y almacenar datos desde la base de datos, puedes seguir avanzando con funcionalidades algo m\u00e1s avanzadas.</p>"},{"location":"04-Nivel-intermedio/","title":"Laravel nivel intermedio","text":""},{"location":"04-Nivel-intermedio/#route-model-binding","title":"Route Model Binding","text":"<p>Normalmente cuando se incluye el ID de un registro en la URL, como por ejemplo en una ruta como <code>/articulos/{id}</code> de tipo <code>GET</code>, lo m\u00e1s com\u00fan es que el controlador de turno tenga que recuperar de la base de datos el registro con el ID indicado. Es por esto que Laravel permite inyectar directamente el modelo entero en lugar del <code>id</code>.</p> <p>A continuaci\u00f3n se muestra un ejemplo en el router: <pre><code>use App\\Models\\Articulo;\n\nRoute::get('/articulos/{articulo}', function (Articulo $articulo) {\n    return $articulo-&gt;titulo;\n});\n</code></pre> Como puede verse, la funci\u00f3n en lugar de recibir el ID como par\u00e1metro recibe directamente el modelo. Esto ha sido gracias a que el par\u00e1metro ha sido declarado del tipo <code>Articulo</code> y el nombre del par\u00e1mentro (<code>$articulo</code>) coincide con el parametro de la ruta (<code>{articulo}</code>).</p> <p>Igualmente se puede hacer en el controlador:</p> <pre><code>use App\\Http\\Controllers\\ArticuloController;\nuse App\\Models\\Articulo;\n\n// Definici\u00f3n de la ruta:\nRoute::get('/articulos/{articulo}', [UserController::class, 'show']);\n\n// Definici\u00f3n del m\u00e9todo en el Controlador:\npublic function show(Articulo $articulo)\n{\n    return view('articulos.index', ['articulo' =&gt; $articulo]);\n}\n</code></pre>"},{"location":"04-Nivel-intermedio/#hands-on","title":"Hands on!","text":"<p>Actualiza la ruta y el controlador ArticuloController de tu aplicaci\u00f3n para que utilice el <code>Route Model Binding</code> cuando el usuario solicite los detalles de un art\u00edculo (show).</p>"},{"location":"04-Nivel-intermedio/#borrado-de-registros","title":"Borrado de registros","text":"<p>El borrado de registros es un tema que suele traer complicaciones, debido a que desde una p\u00e1gina HTML solo es posible enviar peticiones <code>GET</code> y <code>POST</code> (desde formularios). Por lo tanto, las alternativas son las siguientes:</p> <ul> <li>Crear una ruta de tipo <code>GET</code> espec\u00edfica para el borrado. Por ejemplo: <code>/articulos/destroy/{id}</code></li> <li>Hacer la petici\u00f3n de tipo DELETE utilizando AJAX y especificando en la llamada el tipo de m\u00e9todo: <code>'type': 'DELETE'</code></li> <li>Emular la llamada <code>DELETE</code> mediante el campo oculto <code>_method</code>. Para ello podemos utilizar los helpers o directivas de Laravel en un formulario para notificar que se trata de una petici\u00f3n de tipo <code>DELETE</code>:</li> </ul> <pre><code>&lt;form method=\"POST\"&gt;\n     @csrf\n     @method(\"DELETE\")\n\n     &lt;button type=\"submit\"&gt;Eliminar&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>Siguiendo con la \u00faltima de las opciones, quedar\u00eda a\u00f1adir la ruta de borrado al router e implementar el m\u00e9todo <code>destroy()</code> del controlador:</p> <p><pre><code>// Nueva ruta en /router/web.php:\nRoute::delete('/articulos/{articulo}', [ArticuloController::class, 'destroy'])-&gt;name('articulos.destroy');\n\n// M\u00e9todo destroy() en ArticuloContoller:\npublic function destroy(Articulo $articulo)\n{\n    $articulo-&gt;delete();\n    return redirect(route('articulos.index'));\n}\n</code></pre> El borrado de un modelo se puede hacer de forma sencilla invocando al m\u00e9todo <code>delete()</code> del modelo.</p>"},{"location":"04-Nivel-intermedio/#hands-on_1","title":"Hands on!","text":"<p>A\u00f1ade la opci\u00f3n de eliminar cualquier art\u00edculo de la aplicaci\u00f3n.</p>"},{"location":"04-Nivel-intermedio/#actualizar-un-modelo","title":"Actualizar un modelo","text":"<p>Al igual que ocurre con la creaci\u00f3n de un nuevo modelo, para actualizar un modelo los pasos a seguir son los siguientes:</p> <ol> <li>Crear una vista que contenga el formulario de actualizaci\u00f3n. La ruta en este caso ser\u00e1 <code>/articulos/{articulo}/edit</code>.</li> <li>Crear dos rutas que llamen a los m\u00e9todos <code>edit()</code> y <code>update()</code> del controlador: el m\u00e9todo <code>edit()</code> ser\u00e1 el encargado de cargar la vista de actualizaci\u00f3n (creada en el punto anterior) y el m\u00e9todo <code>update()</code> recibir\u00e1 los datos del formulario enviados por el usuario y actualizar\u00e1 el modelo en la base de datos.</li> </ol>"},{"location":"04-Nivel-intermedio/#solucion","title":"Soluci\u00f3n","text":"<p>Nueva vista <code>/resources/views/articulos/edit.blade.php</code>: <pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;RevistApp&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Revistapp&lt;/h1&gt;\n    &lt;h2&gt;Crear un art\u00edculo:&lt;/h2&gt;\n\n    &lt;form method=\"POST\" action=\"{{ route('articulos.update', $articulo) }}\"&gt;\n        @csrf\n        @method('PUT')\n        &lt;p&gt;&lt;label&gt;Titulo: &lt;/label&gt;&lt;input type=\"text\" name=\"titulo\" value=\"{{ $articulo-&gt;titulo }}\"&gt;&lt;/p&gt;\n        &lt;p&gt;&lt;label&gt;Contenido: &lt;/label&gt;&lt;input type=\"text\" name=\"contenido\" value=\"{{ $articulo-&gt;contenido }}\"&gt;&lt;/p&gt;\n        &lt;button type=\"submit\"&gt;Crear&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;a href=\"{{ route('articulos.index') }}\"&gt;Volver&lt;/a&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> En el c\u00f3digo anterior puede verse c\u00f3mo se han asignado los valores actuales a los atributos <code>value</code> de cada campo. Se ha utilizado la directiva <code>@method('PUT')</code> de Laravel para indicar que el m\u00e9todo de env\u00edo ser\u00e1 de tipo <code>PUT</code>.</p> <p>Nuevas rutas a\u00f1adidas a <code>/routes/web.php</code>: <pre><code>Route::get('/articulos/{articulo}/edit', [ArticuloController::class, 'edit'])-&gt;name('articulos.edit');\nRoute::put('/articulos/{articulo}', [ArticuloController::class, 'update'])-&gt;name('articulos.update');\n</code></pre></p> <p>En cuanto a los m\u00e9todos de <code>ArticuloController.php</code>, se utilizar\u00e1 el m\u00e9todo <code>update()</code> para actualizar el modelo: <pre><code>public function edit(Articulo $articulo)\n{\n    return view('articulos.edit', [\n        'articulo' =&gt; $articulo\n    ]);\n}\n\npublic function update(Request $request, Articulo $articulo)\n{\n    $validated = $request-&gt;validate([\n        'titulo' =&gt; 'required|string|max:255',\n        'contenido' =&gt;'required|string'\n    ]);\n    $articulo-&gt;update($validated);\n    return redirect(route('articulos.show', $articulo));\n}\n</code></pre></p>"},{"location":"04-Nivel-intermedio/#construir-layouts","title":"Construir layouts","text":"<p>Las aplicaciones siempre contienen varias parte de la interfaz que son comunes en todas las p\u00e1ginas (la cabecera, men\u00fa de navegaci\u00f3n, footer, etc.). Una de las caracter\u00edsticas de Blade es el uso de Layouts, los cuales permiten de forma muy sencilla compartir entre distintas vistas las partes que tienen en com\u00fan y as\u00ed evitar repetir lo mismo m\u00faltiples veces. La idea consiste en separar en un archivo distinto la parte com\u00fan de nuestras vistas y especificar en ella las zonas que albergar\u00e1n los contenidos espec\u00edficos de cada vista (lo que no es com\u00fan).</p> <p>Empecemos por definir un layout b\u00e1sico:</p> <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;App Name - @yield('titulo')&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"container\"&gt;\n            @yield('content')\n        &lt;/div&gt;\n        &lt;div class=\"big-footer\"&gt;\n            @yield('footer')\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>La directiva <code>@yield</code> se utiliza para especificar el lugar donde se mostrar\u00e1n los contenidos de cada secci\u00f3n.</p> <p>Ahora crearemos la vista concreta que especificar\u00e1 el contenido a introducir en el layout. Es por esto que decimos que la vista extiende (<code>extends</code>) del layout, es decir, la vista heredar\u00e1 toda la estructura definida en el layout y sobreescribir\u00e1 las partes concretas que defina (las secciones).</p> <pre><code>@extends('layouts.master')\n\n@section('titulo', 'Page Title')\n\n@section('content')\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n    &lt;p&gt;This is my body content.&lt;/p&gt;\n@endsection\n\n@section('footer')\n    &lt;p&gt;Built by @JonVadillo.&lt;/p&gt;\n@endsection\n</code></pre> <p><code>@section</code> indica la secci\u00f3n del padre donde ser\u00e1 introducido el contenido especificado entre las etiquetas <code>@section</code> y <code>@endsection</code>.</p>"},{"location":"04-Nivel-intermedio/#hands-on_2","title":"Hands on!","text":"<p>Crea un layout que englobe la parte com\u00fan que contienen todas las vistas de la aplicaci\u00f3n RevistApp. Actualiza las vistas para que extiendan el layout creado.</p>"},{"location":"04-Nivel-intermedio/#laravel-vite-como-trabajar-con-codigo-js-y-css","title":"Laravel Vite: c\u00f3mo trabajar con c\u00f3digo JS y CSS","text":""},{"location":"04-Nivel-intermedio/#introduccion","title":"Introducci\u00f3n","text":"<p>Hoy en d\u00eda en el desarrollo de frontend moderno se utilizan herramientas que compilan y opmitizan el c\u00f3digo Javascript y CSS. En la actualidad predominan Webpack y Vite, siendo este \u00faltimo el que Laravel incluye por defecto a partir de su versi\u00f3n <code>9.19</code>.</p>"},{"location":"04-Nivel-intermedio/#desarrollo-de-frontend-con-laravel","title":"Desarrollo de frontend con Laravel","text":"<p>Por seguridad la \u00fanica carpeta accesible desde el navegador es <code>/public</code>. Nuestro servidor apunta siempre a la carpeta <code>/public</code>, en la que se encuentra el archivo <code>index.php</code> encargado de cargar el framework y redireccionar la petici\u00f3n a la ruta correspondiente.</p> <p>Ser\u00eda posible incluir nuestros archivos <code>.css</code> o <code>.js</code> directamente dentro de nuestra carpeta <code>/public</code>, pero lo habitual en desarrollo web es realizar alg\u00fan tipo de compilaci\u00f3n: por ejemplo utilizar archivos <code>.sass</code> o alg\u00fan framework de JavaScript. Es por esto que es necesaria una herramienta como Vite o Webpack. </p> <p>Configuraremos Vite para que compile los archivos <code>.css</code> y <code>.js</code> que modifiquemos dentro de la carpeta <code>/resources</code> y deje el resultado de la compilaci\u00f3n en la carpeta <code>/public</code>.</p>"},{"location":"04-Nivel-intermedio/#configuracion-de-vite","title":"Configuraci\u00f3n de Vite","text":"<p>Al crear un nuevo proyecto, Laravel crea autom\u00e1ticamente un archivo <code>vite.config.js</code> como este:</p> <p><pre><code>import { defineConfig } from 'vite';\nimport laravel from 'laravel-vite-plugin';\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: true,\n        }),\n    ],\n});\n</code></pre> La configuraci\u00f3n por defecto ya indica a Vite d\u00f3nde se ubican los archivos <code>.css</code> y <code>.js</code>.</p>"},{"location":"04-Nivel-intermedio/#instalar-las-dependencias-e-iniciar-el-servidor-de-vite","title":"Instalar las dependencias e iniciar el servidor de Vite","text":"<p>Para utilizar Vite es necesario tener Node instalado, ya que utilizaremos NPM para instalar las dependencias. Compru\u00e9balo mediante el siguiente comando:</p> <p><pre><code>node -v\n</code></pre> En caso de no tener Node instalado, puedes hacerlo descarg\u00e1ndolo desde la p\u00e1gina web oficial.</p> <p>A continuaci\u00f3n tienes que instalar las dependecias de tu proyecto definidas en el archivo <code>package.json</code> ejecutando el comando <code>npm install</code>. Las dependencias se instalaran en la carpeta <code>node_modules</code>, incluidas Vite y el plugin de Vite para Laravel.</p> <p>El siguiente paso ser\u00e1 iniciar el servidor de Vite: <pre><code>npm run dev\n</code></pre> El servidor de Vite no tiene nada que ver con el servidor web, se trata de un servidor independiente de Vite encargado de realizar las tareas relacionadas con nuestro frontend.</p>"},{"location":"04-Nivel-intermedio/#referenciar-los-archivos-js-y-css-en-las-plantillas-de-blade","title":"Referenciar los archivos JS y CSS en las plantillas de Blade","text":"<p>Para incluir nuestros recursos (assets) en cualquier plantilla de Blade utilizaremos la siguiente directiva:</p> <pre><code>@vite(['resources/css/app.css', 'resources/js/app.js'])\n</code></pre>"},{"location":"04-Nivel-intermedio/#publicar-los-cambios-realizados","title":"Publicar los cambios realizados","text":"<p>Una vez terminemos nuestro desarrollo, ya no ser\u00e1 necesario nuestro servidor Vite. Lo \u00fanico que tendremos que hacer ser\u00e1 publicar en la carpeta <code>/public</code> los archivos compilados y optimizados. Para ello es necesario ejecutar la siguiente sentencia:</p> <p><pre><code>npm run build\n</code></pre> La consola nos mostrar\u00e1 la direcci\u00f3n de los archivos publicados (<code>/public/build/assets/</code>). Este paso ser\u00e1 necesario antes de desplegar nuestra aplicaci\u00f3n en producci\u00f3n.</p>"},{"location":"04-Nivel-intermedio/#utilizar-bootstrap-en-tu-proyecto","title":"Utilizar Bootstrap en tu proyecto","text":"<p>A diferencia de versiones anteriores, a partir de su versi\u00f3n 6, Laravel no incluye por defecto las dependencias necesarias para Bootstrap. Por lo tanto, tendremos 3 opciones para utilizar Bootstrap:</p> <p>a) Referenciar las dependecias JS y CSS utilizando BootstrapCDN (enlaces disponibles en la documentaci\u00f3n oficial). Tal y como indica la web oficial, bastar\u00eda con lo siguiente: <pre><code>&lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n</code></pre></p> <p>b) Descargar las dependecias (enlace) e incluirlas manualmente en las carpetas <code>/public/css</code> y <code>/public/js</code>. </p> <p>c) Utilizar Laravel Mix para compilar nuestros archivos JS y CSS. Nota: Laravel ha sustituido Laravel Mix por Vite a partir de la versi\u00f3n <code>9.19</code>.</p> <p>d) Utilizar Vite como herramienta de compilaci\u00f3n. Actualmente es la opci\u00f3n por defecto de Laravel.</p>"},{"location":"04-Nivel-intermedio/#bootstrap-en-laravel-mix","title":"Bootstrap en Laravel Mix","text":"<p>Laravel Mix es una herramienta basada en Webpack que sirve para compilar los recursos JS y CSS de la parte frontend. En este caso los recursos estar\u00e1n inicialmente ubicados en la carpeta <code>/resources</code> y Laravel Mix dejar\u00e1 dentro de la carpeta <code>/public</code> los archivos resultantes ya minimizados.</p>"},{"location":"04-Nivel-intermedio/#1-instalar-el-paquete-laravelui-mediante-composer","title":"1. Instalar el paquete Laravel/UI mediante composer.","text":"<pre><code>composer require laravel/ui\n</code></pre>"},{"location":"04-Nivel-intermedio/#2-anadir-bootstrap-a-nuestro-proyecto","title":"2. A\u00f1adir bootstrap a nuestro proyecto","text":"<pre><code>php artisan ui bootstrap\n</code></pre>"},{"location":"04-Nivel-intermedio/#3-instalar-las-dependencias","title":"3. Instalar las dependencias","text":"<p>El siguiente comando instalar\u00e1 las dependencias necesarias: <pre><code>npm install\n</code></pre> En ocasiones, al utilizar Vagrant puede haber problemas si la m\u00e1quina virtual se ejecuta en un host con Windows 10, por lo que en ese caso lanzar:</p> <p><pre><code>npm install --no-bin-links\n</code></pre> Este problema viene porque al realizar la acci\u00f3n <code>npm install</code> dentro de nuestra m\u00e1quina virtual (Linux) se intentan crear enlaces simb\u00f3licos, pero al estar \u00e9sta sincronizada con Windows (sistema operativo del host) salta el error ya que esto no es posible en un sistema NTFS.</p> <p>En caso de que el error persista, puede que sea necesario hacer antes un borrado (<code>rm -rf node_modules</code>) y luego ejecutar <code>npm install --no-bin-links</code>.</p>"},{"location":"04-Nivel-intermedio/#4-compilar-el-codigo-js-y-css-mediante-webpack","title":"4. Compilar el c\u00f3digo JS y CSS mediante Webpack:","text":"<p>El siguiente paso es compilar los recursos ubicados en <code>/resources</code>: <pre><code>/* para el entorno de desarrollo  */\nnpm run dev\n\n/* para el entorno de producci\u00f3n */\nnpm run production\n</code></pre> El comando anterior tambi\u00e9n dejar\u00e1 los archivos compilados en la carpeta <code>/public</code>.</p> <p>Es posible que ejecutar el comando desde la m\u00e1quina virtual d\u00e9 error. Si es as\u00ed, ejecutarlo desde el la m\u00e1quina host.</p> <p>En caso de tener alg\u00fan problema con el reconocimiento de la herramienta Laravel Mix, volver a instalarla mediante el comando <code>npm install laravel-mix@latest</code> y una vez terminada su instalaci\u00f3n lanzar el comando <code>npm run dev</code>.</p>"},{"location":"04-Nivel-intermedio/#5-incluir-los-ficheros-generados-publicjsappjs-y-publiccssappcss-en-nuestras-vistas-utilizando-el-metodo-helper-asset","title":"5. Incluir los ficheros generados (<code>public/js/app.js</code> y <code>public/css/app.css</code>) en nuestras vistas, utilizando el m\u00e9todo helper <code>asset()</code>:","text":"<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Mi aplicaci\u00f3n&lt;/title&gt;\n    &lt;link href=\"{{ asset('css/app.css') }}\" rel=\"stylesheet\" type=\"text/css\" /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Bienvenido a mi app&lt;/h1&gt;\n    &lt;div class=\"content\"&gt;\n        @yield('content')\n    &lt;/div&gt;\n    &lt;script src=\"{{ asset('js/app.js') }}\" type=\"text/js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>El m\u00e9todo <code>asset()</code> generar\u00e1 una URL a nuestros recursos en la carpeta <code>public/</code>. Si cambiamos la ubicaci\u00f3n de nuestros recursos lo tendremos que especificar en la variable <code>ASSET_URL</code> del fichero <code>.env</code>.</p>"},{"location":"04-Nivel-intermedio/#bootstrap-con-vite","title":"Bootstrap con Vite","text":"<p>Secci\u00f3n en construcci\u00f3n.</p>"},{"location":"04-Nivel-intermedio/#hands-on-opcional","title":"Hands on! (opcional)","text":"<p>A\u00f1ade estilo a la aplicaci\u00f3n mediante el framework Bootstrap 5.</p>"},{"location":"04-Nivel-intermedio/#relaciones-one-to-many","title":"Relaciones One-to-Many","text":""},{"location":"04-Nivel-intermedio/#definir-una-relacion","title":"Definir una relaci\u00f3n","text":"<p>Las relaciones en Eloquent ORM se definen como m\u00e9todos. Supongamos que tenemos dos entidades, <code>User</code> y <code>Articulo</code>. Podr\u00edamos decir que un <code>User</code> tiene (has) varios <code>Articulo</code> o que un <code>Articulo</code> pertenece a (belongs to) un <code>User</code>. Por lo tanto, podemos definir la relaci\u00f3n en cualquiera de los dos modelos, incluso en los dos.</p> <pre><code>class User extends Model\n{\n    /**\n     * Get the articulos records associated with the user.\n     */\n    public function articulos()\n    {\n        return $this-&gt;hasMany(Articulo::class);\n    }\n}\n</code></pre> <p><pre><code>class Articulo extends Model\n{\n    /**\n     * Get the user record associated with the articulo.\n     */\n    public function user()\n    {\n        return $this-&gt;belongsTo(User::class);\n    }\n}\n</code></pre> Tienes toda la informaci\u00f3n sobre c\u00f3mo definir relaciones entre modelos en la documentaci\u00f3n oficial.</p>"},{"location":"04-Nivel-intermedio/#acceder-a-los-modelos-de-una-relacion","title":"Acceder a los modelos de una relaci\u00f3n","text":"<p>El acceso se podr\u00e1 hacer como propiedades del propio modelo, es decir, mediante <code>$user-&gt;articulos</code> o <code>$articulo-&gt;user</code>. Esto es gracias a que Eloquent utiliza lo que conocemos como 'dynamic properties' y acceder a los m\u00e9todos de las relaciones como si fuesen propiedades:</p> <pre><code>$user = App\\Models\\User::find(1); // Ejecuta la sentencia: select * from users where id = 1\n\n$user_articulos = $user-&gt;articulos; // Ejecutara la sentencia: select * from articulos where user_id = 1\n\nforeach ($user_articulos as $articulo) {\n    //\n}\n</code></pre> <p>En el ejemplo anterior, la variable <code>$user_articulos</code> contiene una colecci\u00f3n de objetos de la clase <code>Articulo</code>. </p>"},{"location":"04-Nivel-intermedio/#eager-load-y-lazy-load","title":"Eager load y lazy load","text":"<p>Al obtener la informaci\u00f3n de un modelo puedes hacerlo de dos maneras, utilizando lazy load (por defecto) o eager load. Resumi\u00e9ndolo en pocas palabras, con lazy loading se cargar\u00e1 la informaci\u00f3n en el momento que vaya a ser utilizada, mientras que eager loading consiste en realizar una carga previa de la informaci\u00f3n porque se sabe de antemano que se dar\u00e1 uso de ella.  </p> <p>En estos dos ejemplos ver\u00e1s claramente la utilidad de ambos patrones de dise\u00f1o.  </p>"},{"location":"04-Nivel-intermedio/#ejemplo-1","title":"Ejemplo 1","text":"<p>Imagina que tienes 20 usuarios registrados y quieres recorrerlos todos accediendo en cada uno de ellos a su lista de art\u00edculos.  </p> <p>Utilizando lazy loading <pre><code>$users = User::all(); // select * from users\nforeach ($users as $user) {\n    $user_articulos = $user-&gt;articulos; // select * from articulos where user_id = $user-&gt;id\n    // ...\n}\n// Sentencias totales: 21\n// \u274c Lazy Loading en este caso supondr\u00eda un impacto de rendimiento\n// A esto se le conoce como problema de sentencias N+1 \ud83d\udc48 \u00a1cuidado!\n</code></pre></p> <p>Utilizando eager loading <pre><code>$users = User::with(['articulos'])-&gt;get(); // Ejecuta 2 sentencias\n        // 1- select * from users\n        // 2- select * from articulos where user_id IN (1, 2, 3, 4, ..., 20)\nforeach ($users as $user) {\n    $user_articulos = $user-&gt;articulos; // Informaci\u00f3n previamente cargada\n    // ...\n}\n// Sentencias totales: 2\n// \u2705 Eager loading en este ser\u00eda una optimizaci\u00f3n de rendimiento\n</code></pre></p>"},{"location":"04-Nivel-intermedio/#ejemplo-2","title":"Ejemplo 2","text":"<p>Ahora sup\u00f3n que tienes tambi\u00e9n 20 usuarios y quieres recogerlos todos pero \u00fanicamente acceder a la lista de art\u00edculos de los 5 primeros <pre><code>// \u25b6 Utilizando lazy loading\n$users = User::all(); // select * from users\nforeach ($users as $user) {\n    if ($user-&gt;id &lt; 6) {\n        $user_articulos = $user-&gt;articulos; // select * from articulos where user_id = $user-&gt;id\n        // ...\n    }\n    // ...\n}\n// \u00danicamente se ha cargado la informaci\u00f3n necesaria\n// \u2705 En este caso lazy loading ser\u00eda ideal\n\n// \u25b6 Utilizando eager loading\n$users = User::with(['articulos'])-&gt;get(); // Ejecuta 2 sentencias\n        // 1- select * from users\n        // 2- select * from articulos where user_id IN (1, 2, 3, 4, ..., 20)\nforeach ($users as $user) {\n    if ($user-&gt;id &lt; 6) {\n        $user_articulos = $user-&gt;articulos; // Informaci\u00f3n previamente cargada\n        // ...\n    }\n    // ...\n}\n// Se ha cargado mucha informaci\u00f3n que no ha sido utilizada\n// \u274c Eager loading supondr\u00eda una carga innecesaria\n</code></pre> En estos ejemplos sencillos se est\u00e1 dando uso del m\u00e9todo <code>with</code> para decirle al modelo que se cargue con la relaci\u00f3n se\u00f1alada, puedes aprender m\u00e1s sobre c\u00f3mo aplicar eager loading en la documentaci\u00f3n oficial. Si sientes que no te ha quedado claro, aqu\u00ed tienes un v\u00eddeo que explica lo mismo pero de manera m\u00e1s clara y visual.</p>"},{"location":"04-Nivel-intermedio/#crear-la-restriccion-de-las-claves-foraneas-en-la-base-de-datos","title":"Crear la restricci\u00f3n de las claves for\u00e1neas en la Base de Datos","text":"<p>Como es l\u00f3gico, para que el modelo pueda acceder a otro modelo con el que mantiene una relaci\u00f3n one-to-many, es necesario especificar la <code>foreign key</code> correspondiente a nivel de base de datos. Recordemos que las foreign key permiten mantener la integridad referencial en nuestra base de datos.</p> <p>Por defecto, si no indicamos lo contrario, el modelo de Eloquent utilizar\u00e1 como foreign key el nombre del modelo que contiene la colecci\u00f3n a\u00f1adiendo el sufijo <code>'_id'</code>. Es decir, en el caso anterior la tabla de <code>Articulo</code> deber\u00e1 contener una columna llamada <code>'user_id'</code>, ya que el nombre del otro modelo es <code>User</code>. Por lo tanto nuestra migraci\u00f3n deber\u00eda quedar de la siguiente forma:</p> <p><pre><code>    public function up()\n    {\n        Schema::create('articulos', function (Blueprint $table) {\n            $table-&gt;id();\n            $table-&gt;foreignId('user_id')-&gt;constrained()-&gt;cascadeOnDelete();\n\n            $table-&gt;string('titulo');\n            $table-&gt;text('contenido');\n            $table-&gt;timestamps();\n        });\n    }\n}\n</code></pre> Expliquemos la siguiente sentencia: <pre><code>$table-&gt;foreignId('user_id')-&gt;constrained()-&gt;cascadeOnDelete();\n</code></pre> - <code>foreignId</code> crea una columna del tipo <code>UNSIGNED BIGINT</code> con el nombre especificado. - <code>constrained</code> utilizar\u00e1 las convenciones de Laravel para determinar la tabla y columna a la que se refiere. Nota: si no sigui\u00e9semos las convenciones, podr\u00edamos indicarle el nombre de la tabla pas\u00e1ndoselo como argumento: <code>constrainded('users')</code>. - <code>cascadeOnDelete</code> indica las acciones a realizar cuando se vaya a borrar el registro. El borrado en cascada determina que si el usuario que contiene los art\u00edculos es borrado, se borrar\u00e1n tambi\u00e9n todos sus art\u00edculos. Otras opciones ser\u00edan <code>restrictedOnDelete</code> (restringe el borrado mientras tenga art\u00edculos referenciados) o <code>nullOnDelete</code> (establece el valor <code>NULL</code> a la foreign key de los art\u00edculos relacionados).</p>"},{"location":"04-Nivel-intermedio/#consejo-como-anadir-columnas-a-modelo-existente","title":"Consejo: c\u00f3mo a\u00f1adir columnas a modelo existente","text":"<p>Existen dos escenarios posibles en los cuales queremos realizar cambios sobre modelos existentes: - Estamos desarrollando una nueva aplicaci\u00f3n y no nos importa borrar los datos existentes. - Tenemos una aplicaci\u00f3n en uso y queremos a\u00f1adir columnas sin perder ning\u00fan registro.</p> <p>En el primer caso, es suficiente con modificar la migraci\u00f3n de la tabla correspondiente y ejecutar el comando:</p> <p><pre><code>php artisan migrate:fresh\n</code></pre> Este comando eliminar\u00e1 todas las tablas de la base de datos y volver\u00e1 a crearlas desde cero.</p> <p>Para el segundo caso (modificar una tabla sin perder datos), lo recomendable es crear una nueva migraci\u00f3n y ejecutar el comando <code>php artisan migrate</code> para lanzar los cambios. Normalmente se incluyen los cambios en el propio nombre de la migraci\u00f3n, por ejemplo:</p> <pre><code>php artisan migrate:make add_category_to_articulos --table=\"articulos\"\n</code></pre> <pre><code>public function up()\n{\n    Schema::table('articulos', function($table)\n    {\n        $table-&gt;string('category');\n    });\n    }\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::table('articulos', function ($table) {\n        $table-&gt;dropColumn('category');\n        });\n    }\n}\n</code></pre>"},{"location":"04-Nivel-intermedio/#hands-on_3","title":"Hands on!","text":"<p>La vista de detalle de art\u00edculo mostrar\u00e1 los comentarios del art\u00edculo e incluir\u00e1 la posibilidad de a\u00f1adir nuevos comentarios.</p>"},{"location":"04-Nivel-intermedio/#generar-datos-de-prueba","title":"Generar datos de prueba","text":"<p>Laravel incluye un mecanismo llamado Seeder que sirve para rellenar la base de datos con datos de prueba. Por defecto nos incluye la clase DatabaseSeeder en la que podemos incluir el c\u00f3digo que genere los datos de prueba:</p> <pre><code>class DatabaseSeeder extends Seeder\n{\n    /**\n     * Seed the application's database.\n     *\n     * @return void\n     */\n    public function run()\n    {\n        $faker = \\Faker\\Factory::create();\n\n        for($i=0;$i&lt;10;$i++){\n            DB::table('articulos')-&gt;insert([\n                'titulo' =&gt; $faker-&gt;text(50),\n                'contenido' =&gt; $faker-&gt;text(400)\n            ]);\n        }\n    }\n}\n</code></pre> <p>Una vez creado nuestro Seeder es probable que necesites regenerar el fichero autoload.php:</p> <pre><code>composer dump-autoload\n</code></pre> <p>Por \u00faltimo, s\u00f3lo nos quedar\u00eda lanzar el proceso de 'seeding':</p> <pre><code>php artisan db:seed\n</code></pre> <p>Si lo que quieres es lanzar el proceso de creaci\u00f3n de base de datos y el de seeding a la vez, puedes utilizar el siguiente comando:</p> <pre><code>php artisan migrate:fresh --seed\n</code></pre>"},{"location":"04-Nivel-intermedio/#generar-seeders-especificos","title":"Generar Seeders espec\u00edficos","text":"<p>Es recomendable crear un seeder espec\u00edfico por cada entidad. Para ello, puedes utilizar el siguiente comando:</p> <pre><code>php artisan make:seeder UsersTableSeeder\n</code></pre> <p>Por \u00faltimo, tendr\u00e1s que modificar la clase DatabaseSeeder para que lance nuestros Seeders:</p> <pre><code>public function run()\n{\n    $this-&gt;call([\n        UsersTableSeeder::class,\n        PostsTableSeeder::class,\n        CommentsTableSeeder::class,\n    ]);\n}\n</code></pre>"},{"location":"04-Nivel-intermedio/#uso-de-factories","title":"Uso de factories","text":"<p>A la hora de generar datos para testing tambi\u00e9n es recomendable utilizar Factories para crear los objetos de BBDD. Una Factory simplemente es una clase que define los atributos que tendr\u00e1 un objeto en su creaci\u00f3n. En el siguiente ejemplo se muestra una posible factory para la clase Articulo:</p> <p><pre><code>&lt;?php\n\nnamespace Database\\Factories;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\n\nclass ArticuloFactory extends Factory\n{\n    /**\n     * Define the model's default state.\n     *\n     * @return array\n     */\n    public function definition()\n    {\n        return [\n            'titulo' =&gt; $this-&gt;faker-&gt;text($maxNbChars = 50),\n            'contenido' =&gt; $this-&gt;faker-&gt;text($maxNbChars = 400)\n        ];\n    }\n}\n</code></pre> Es suficiente con implementar el m\u00e9todo <code>definition</code> y especificar en \u00e9l las propiedades del objeto que se crear\u00e1.  Una vez tenemos creadas las factories, solo nos quedar\u00eda utilizarlas desde el Seeder correspondiente:</p> <pre><code>class DatabaseSeeder extends Seeder\n{\n    /**\n     * Seed the application's database.\n     *\n     * @return void\n     */\n    public function run()\n    {\n        \\App\\Models\\Articulo::factory(20)-&gt;create();\n    }\n}\n</code></pre> <p>La creaci\u00f3n de factories se puede realizar mediante el comando <code>php artisan make:factory</code>. Por ejemplo:</p> <pre><code>php artisan make:factory ArticuloFactory\n</code></pre>"},{"location":"04-Nivel-intermedio/#autenticacion","title":"Autenticaci\u00f3n","text":"<p>La autenticaci\u00f3n es una funcionalidad presente en la gran mayor\u00eda de aplicaciones. B\u00e1sicamente se trata de asegurar que un usuario es qui\u00e9n dice ser mediante un control de acceso a la aplicaci\u00f3n.</p> <p>Las opciones principales que provee Laravel para implementarl la autenticaci\u00f3n son: - Laravel UI - Laravel Breeze (opci\u00f3n recomendada a partir de Laravel 8)</p>"},{"location":"04-Nivel-intermedio/#autenticacion-con-laravel-ui","title":"Autenticaci\u00f3n con Laravel UI","text":"<p>A partir de la versi\u00f3n 6 de Laravel es posible utilizar el paquete <code>laravel/ui</code> para implementar funcionalidades de autenticaci\u00f3n. Laravel UI nos trae de serie algunos elementos necesarios para implementar la autenticaci\u00f3n en nuestras aplicaciones y no tener que preocuparnos de hacer todas las tareas por nosotros mismos (login, registro, recuperaci\u00f3n de contrase\u00f1a, validaci\u00f3n de usuario, etc.).</p> <p>En concreto necesitaremos lo siguiente: - Generar las vistas (login, registro, etc.), rutas y sus respectivas implementaciones. - Especificar las partes de nuestra web (rutas) que queramos proteger.</p>"},{"location":"04-Nivel-intermedio/#paso-1-crear-la-estructura-necesaria","title":"Paso 1: Crear la estructura necesaria","text":"<p>El primer paso es instalar el paquete de laravel/ui mediante Composer: <pre><code>composer require laravel/ui\n</code></pre></p> <p>Este paquete nos permitir\u00e1 generar de forma autom\u00e1tica todo lo relacionado con la interfaz de usuario: vistas, rutas y un nuevo controlador llamado <code>HomeController</code>. Tail y como dice la documentaci\u00f3n oficial, en funci\u00f3n de nuestras necesidades, podremos elegir entre uno de los siguientes comandos:</p> <pre><code>// Generate basic scaffolding...\nphp artisan ui bootstrap\nphp artisan ui vue\nphp artisan ui react\n\n// Generate login / registration scaffolding...\nphp artisan ui bootstrap --auth\nphp artisan ui vue --auth\nphp artisan ui react --auth\n</code></pre> <p>En el caso de esta gu\u00eda ejecutaremos el comando que genera las funciones de login y registro utilizando el framework Bootstrap: <pre><code>php artisan ui bootstrap --auth\n</code></pre></p> <p>Si te fijas bien, el router <code>web.php</code> incluye dos nuevas l\u00edneas:</p> <pre><code>Auth::routes();\n\nRoute::get('/home', 'HomeController@index')-&gt;name('home');\n</code></pre> <p>La primera genera de forma autom\u00e1tica las rutas necesarias para el proceso de autenticaci\u00f3n (prueba a acceder a <code>/login</code> o <code>/register</code> para comprobarlo). Las vistas que se cargan son las autogeneradas en <code>resources/views/auth</code> (tambi\u00e9n se ha creado un layout).</p> <p>La segunda es simplemente un nuevo controlador autogenerado como ejemplo. Si intentas acceder a la ruta creada <code>/home</code> ver\u00e1s como la aplicaci\u00f3n nos lleva a la p\u00e1gina de login. Esto es porque el controlador <code>HomeController</code> est\u00e1 definido como 'seguro' y solo usuarios autenticados podr\u00e1n acceder.</p> <p>\u00a1Felicidades! Ya tienes la estructura b\u00e1sica de la aplicaci\u00f3n creada. Puedes probar a registrar nuevos usuarios y realizar las acciones de login o logout con ellos.</p>"},{"location":"04-Nivel-intermedio/#paso-2-configuracion-basica","title":"Paso 2: Configuraci\u00f3n b\u00e1sica","text":"<p>Una de las cosas que tendr\u00e1s que configurar es la ruta a la que se env\u00eda al usuario tras autenticarse. Esto puede especificarse  mediante la variable <code>HOME</code> del archivo <code>RouteServiceProvider</code>:</p> <pre><code>public const HOME = '/home';\n</code></pre> <p>Laravel utiliza por defecto el campo <code>email</code> para identificar a los usuarios. Puedes cambiar esto creando un m\u00e9todo <code>username()</code> en el controlador <code>LoginController</code>.</p> <pre><code>public function username()\n{\n    return 'username';\n}\n</code></pre> <p>Otro aspecto que podremos configurar es la ruta a la que enviaremos al usuario cuando intente acceder a una ruta protegida sin autenticarse. Por defecto Laravel le enviar\u00e1 a <code>/login</code>, pero podemos cambiar esto modificando el m\u00e9todo <code>redirectTo()</code> del archivo <code>app/Http/Middleware/Authenticate.php</code>:</p> <pre><code>protected function redirectTo($request)\n{\n    return route('login');\n}\n</code></pre>"},{"location":"04-Nivel-intermedio/#paso-3-securizar-rutas","title":"Paso 3: Securizar rutas","text":"<p>Indicaremos las rutas que queramos proteger directamente en nuestro ruter <code>web.php</code>:</p> <pre><code>Route::get('profile', function () {\n    // Solo podr\u00e1n acceder usuarios autenticados.\n})-&gt;middleware('auth');\n</code></pre> <p>Tambi\u00e9n podremos indicarlo directamente en el constructor de un controlador de la siguiente forma:</p> <pre><code>public function __construct()\n{\n    $this-&gt;middleware('auth');\n}\n</code></pre>"},{"location":"04-Nivel-intermedio/#paso-4-conseguir-el-usuario-autenticado","title":"Paso 4: Conseguir el usuario autenticado","text":"<p>Existen distintas formas de acceder al objeto del usuario autenticado. Desde cualquier punto de la aplicaci\u00f3n podremos acceder utilizado la facade <code>Auth</code>:</p> <pre><code>use Illuminate\\Support\\Facades\\Auth;\n\n// Conseguir el usuario autenticado:\n$user = Auth::user();\n\n// Conseguir el ID del usuario autenticado:\n$id = Auth::id();\n</code></pre> <p>Tambi\u00e9n podremos conseguirlo desde cualquier petici\u00f3n:</p> <pre><code>public function update(Request $request)\n{\n    $request-&gt;user(); //  devuelve una instancia del usuario autenticado.\n}\n</code></pre> <p>Para comprobar si un usuario est\u00e1 autenticado, podemos emplear el m\u00e9todo <code>check()</code>:</p> <pre><code>use Illuminate\\Support\\Facades\\Auth;\n\nif (Auth::check()) {\n    // El usuario est\u00e1 autenticado.\n}\n</code></pre>"},{"location":"04-Nivel-intermedio/#autenticacion-con-laravel-breeze","title":"Autenticaci\u00f3n con Laravel Breeze","text":"<p>A partir de la versi\u00f3n 8 de Laravel se recomienda utilizar Laravel Breeze, el cual utiliza Tailwind CSS en lugar de Bootstrap. Este aspecto es importante ya que afecta a las vistas creadas. Laravel Breeze es una implementaci\u00f3n sencilla de las funciones m\u00e1s habituales de autenticaci\u00f3n como: login, registro, recuperaci\u00f3n de contrase\u00f1a, verificaci\u00f3n de correo electr\u00f3nico o confirmaci\u00f3n de contrase\u00f1a por correo. Para ello crear\u00e1 todas las vistas, rutas y controladores necesarios y adem\u00e1s los dejar\u00e1 disponibles en el c\u00f3digo de nuestro proyecto para que podamos modificar todo aquello que necesitemos.</p>  <p>Laravel Breeze debe instalarse tras la creaci\u00f3n del proyecto</p> <p>Laravel Breeze debe instalarse sobre un proyecto reci\u00e9n creado de Laravel, ya que eliminar\u00e1 c\u00f3digo existente en rutas, etc. Es lo que Laravel considera un Starter Kit.</p>  <p>Para instalar Laravel Breeze es necesario lanzar el siguiente comando para instalar el paquete utilizando Composer:</p> <pre><code>composer require laravel/breeze --dev\n</code></pre> <p>A continuaci\u00f3n el siguiente comando generar\u00e1 todo el c\u00f3digo necesario en tu proyecto:</p> <pre><code>php artisan breeze:install\n</code></pre> <p>El comando anterior habra hecho varios cambios en el proyecto, como por ejemplo: - Crear los controladores necesarios para el login, registro, recuperaci\u00f3n de contrase\u00f1a, etc. - Crear las vistas empleadas por los controladores (utilizando Tailwind CSS). - Crear una vista llamada Dashboard que utilizaremos cuando un usuario se autentica correctamente. - Crear los ficheros CSS y JS necesarios, que luego habr\u00e1 que compilar. - Crear las rutas relacionadas con la autenticaci\u00f3n en el archivo <code>auth.php</code>.</p> <p>Al igual que se hace con el resto de archivos est\u00e1ticos que queremos compilar y publicar en la carpeta <code>/public</code>, tendremos que lanzar los comandos <code>npm install</code> y <code>npm run dev</code>.</p> <p>Por \u00faltimo, no olvides lanzar las migraciones necesarias mediante el comando <code>php artisan migrate</code>.</p>"},{"location":"04-Nivel-intermedio/#hands-on_4","title":"Hands on!","text":"<ul> <li>A\u00f1ade las funciones de login, registro y logout a la aplicaci\u00f3n.</li> <li>Protege la ruta empleada para escribir un nuevo art\u00edculo (solo usuarios autenticados podr\u00e1n acceder).</li> <li>La opci\u00f3n de borrar un art\u00edculo \u00fanicamente estar\u00e1 visible para usuarios autenticados.</li> <li>Muestra los comentarios de los art\u00edculos \u00fanicamente a usuarios autenticados. A los usuarios no identificados mu\u00e9strales un mensaje con un enlace a la p\u00e1gina de login.</li> </ul>"},{"location":"04-Nivel-intermedio/#manejo-de-sesiones","title":"Manejo de sesiones","text":"<p>HTTP es un protocolo sin estado (stateless), es decir, no guarda ninguna informaci\u00f3n sobre conexiones anteriores. Esto quiere decir que nuestra aplicaci\u00f3n no tiene \"memoria\", y cada petici\u00f3n realizada por un usuario es nueva para la aplicaci\u00f3n. Las sesiones permiten afrontar este problema, ya que son un mecanismo para almacenar informaci\u00f3n entre las peticiones que realiza un usuario al navegar por nuestra aplicaci\u00f3n. Laravel implementa las sesiones de forma que su uso es muy sencillo para los desarrolladores.</p>"},{"location":"04-Nivel-intermedio/#configuracion","title":"Configuraci\u00f3n","text":"<p>Laravel soporta el manejo de sesiones con distintos backends (bases de datos, ficheros, etc.). Esta configuraci\u00f3n se indica en el fichero <code>config/session.php</code>, en le que podemos indicar el driver a utilizar (\"file\", \"cookie\", \"database\", \"apc\", \"memcached\", \"redis\", \"dynamodb\" o \"array\"). La opci\u00f3n utilizada por defecto es \"cookie\", la cual es suficiente para la mayor\u00eda de aplicaciones.</p> <p>M\u00e1s informaci\u00f3n sobre la configuraci\u00f3n en la documentaci\u00f3n oficial.</p>"},{"location":"04-Nivel-intermedio/#uso-de-las-sesiones","title":"Uso de las sesiones","text":"<p>Existen dos formas principales de acceder a la informaci\u00f3n de la sesi\u00f3n de usuario: -  El helper global <code>session</code> <pre><code>// Obtener un valor de la sesi\u00f3n\n$value = session('key');\n\n// Podemos indicar un valor por defecto\n$value = session('key', 'default');\n\n// Para almacenar un valor, le pasamos un Array:\nsession(['key' =&gt; 'value']);\n</code></pre> -  Mediante la instancia <code>Request</code> (inyectada en los m\u00e9todos de nuestros controladores)</p> <pre><code>public function show(Request $request, $id)\n{\n    $value = $request-&gt;session()-&gt;get('key');\n\n    // Tambi\u00e9n es posible indicar un valor por defecto si no existe ninguno:\n    $value = $request-&gt;session()-&gt;get('key', 'default');\n\n    // Almacenar un valor\n    $request-&gt;session()-&gt;put('key', 'value');\n\n    // Recuperar un valor y eliminarlo de la sesi\u00f3n\n    $value = $request-&gt;session()-&gt;pull('key', 'default');\n}\n</code></pre> <p>Tambi\u00e9n es posible acceder a valores de la sesi\u00f3n desde las vistas de Blade utilizardo la funci\u00f3n <code>get()</code>:</p> <pre><code> Session::get('key')\n</code></pre>"},{"location":"04-Nivel-intermedio/#hands-on_5","title":"Hands on!","text":"<p>A\u00f1ade las siguientes funcionalidades a la aplicaci\u00f3n: - Guardar en sesi\u00f3n los art\u00edculos le\u00eddos: cuando un usuario entre a ver un art\u00edculo, se almacenar\u00e1 en sesi\u00f3n que ya lo ha le\u00eddo. - Guardar en sesi\u00f3n los art\u00edculos favoritos de un usuario: el usuario podr\u00e1 hacer click en un enlace/bot\u00f3n que guarde en sesi\u00f3n ese art\u00edculo como favorito.</p> <p>Los art\u00edculos marcados como favoritos se podr\u00e1n distinguir visualmente (mediante un icono, texto en negrita o similar). Igualmente, los art\u00edculos le\u00eddos se mostrar\u00e1n tambi\u00e9n de forma especial.</p>"},{"location":"04-Nivel-intermedio/#validacion-de-formularios","title":"Validaci\u00f3n de formularios","text":""},{"location":"04-Nivel-intermedio/#realizar-la-validacion-de-los-campos-del-formulario","title":"Realizar la validaci\u00f3n de los campos del formulario","text":"<p>Laravel permite validar cualquier campo enviado por un formulario mediante el m\u00e9todo <code>validate</code>. Tal y como ya hab\u00edamos hecho anteriormente:</p> <p><pre><code>public function store(Request $request)\n{\n    //Validar la petici\u00f3n:\n    $validated = $request-&gt;validate([\n        'titulo' =&gt; 'required|string|max:255',\n        'contenido' =&gt;'required|string'\n    ]);\n\n    Articulo::create($validated);\n\n    return redirect(route('articulos.index'));\n}\n</code></pre> Si la validaci\u00f3n pasa correctamente el c\u00f3digo seguir\u00e1 ejecut\u00e1ndose de forma normal y corriente. Pero si la validaci\u00f3n falla, se redirigir\u00e1 al usuario a la p\u00e1gina desde la que se ha realizado el env\u00edo del formulario. </p> <p>Puedes ver todas las reglas de validaci\u00f3n disponibles aqu\u00ed.</p>"},{"location":"04-Nivel-intermedio/#mostrar-los-errores-en-la-vista","title":"Mostrar los errores en la vista","text":"<p>Todas las vistas de Laravel tienen disponible la variable llamada <code>$errors</code>. En el siguiente ejemplo puede verse c\u00f3mo mostrar al usuario todos los errores detectados en la validaci\u00f3n:</p> <pre><code>&lt;h1&gt;Crear art\u00edculo&lt;/h1&gt;\n\n@if ($errors-&gt;any())\n    &lt;div class=\"alert alert-danger\"&gt;\n        &lt;ul&gt;\n            @foreach ($errors-&gt;all() as $error)\n                &lt;li&gt;{{ $error }}&lt;/li&gt;\n            @endforeach\n        &lt;/ul&gt;\n    &lt;/div&gt;\n@endif\n</code></pre>"},{"location":"04-Nivel-intermedio/#directiva-error","title":"Directiva <code>@error</code>","text":"<p>La directiva <code>@error</code> permite comprobar si un campo concreto ha tenido alg\u00fan error, y en caso afirmativo mostrar el mensaje de error de dicho campo. Se utilizar\u00e1 de la siguiente manera:</p> <p><pre><code>&lt;p&gt;\n    &lt;label&gt;Titulo: &lt;/label&gt;\n    &lt;input type=\"text\" name=\"titulo\"&gt;\n    @error('titulo')\n    &lt;small style=\"color:red;\"&gt;{{ $message }}&lt;/small&gt;\n    @enderror\n&lt;/p&gt;\n&lt;p&gt;\n    &lt;label&gt;Titulo: &lt;/label&gt;\n    &lt;input type=\"text\" name=\"contenido\"&gt;\n    @error('contenido')\n    &lt;small style=\"color:red;\"&gt;{{ $message }}&lt;/small&gt;\n    @enderror\n&lt;/p&gt;\n</code></pre> En caso de error se mostrar\u00e1 el contenido indicado entre las etiquetas <code>@error</code> y <code>@enderror</code>. Adem\u00e1s la variable <code>$message</code> estar\u00e1 disponible entre dichas etiquetas e incluir\u00e1 el mensaje de error.</p>"},{"location":"04-Nivel-intermedio/#mantener-el-valor-de-los-campos-correctos","title":"Mantener el valor de los campos correctos","text":"<p>En caso de que el formulario tenga varios campos correctos, puede ser interesante mantener los valores enviados previamente en lugar de resetear el formulario entero. El valor de los campos que hab\u00edan sido completados correctamente puede recuperarse mediante la funci\u00f3n <code>old</code> de Laravel:</p> <pre><code>&lt;input type=\"text\" name=\"titulo\" value=\"{{old('titulo')}}\"&gt;\n</code></pre>"},{"location":"04-Nivel-intermedio/#traduccion-de-los-mensajes-de-error","title":"Traducci\u00f3n de los mensajes de error","text":"<p>Los mensajes de error pueden verse en el fichero <code>lang/en/validation.php</code>. En caso de quere traducirlos a otro idioma, bastar\u00eda con crear un fichero con la misma estructura bajo el directorio del nuevo idioma. Por ejemplo: <code>lang/es/validation.php</code></p> <p>En caso de querer profundizar m\u00e1s en la detecci\u00f3n y visualizaci\u00f3n de errores, puedes encontrar m\u00e1s informaci\u00f3n en la p\u00e1gina oficial.</p>"}]}